"""
T1211 - Exploitation for Defense Evasion

Adversaries exploit system or application vulnerabilities to circumvent security
features and defensive controls. Includes exploiting security software directly.
Used by APT28, Velvet Ant.
"""

from .template_loader import (
    RemediationTemplate,
    ThreatContext,
    DetectionStrategy,
    DetectionImplementation,
    DetectionType,
    EffortLevel,
    FalsePositiveRate,
    CloudProvider,
)

TEMPLATE = RemediationTemplate(
    technique_id="T1211",
    technique_name="Exploitation for Defense Evasion",
    tactic_ids=["TA0005"],
    mitre_url="https://attack.mitre.org/techniques/T1211/",
    threat_context=ThreatContext(
        description=(
            "Adversaries exploit system or application vulnerabilities to bypass "
            "security features and defensive controls. This includes exploiting "
            "security software directly, cloud IaaS/SaaS platforms, and operating "
            "system kernels to evade detection and logging mechanisms."
        ),
        attacker_goal="Bypass security controls by exploiting vulnerabilities in defensive software",
        why_technique=[
            "Disable security monitoring",
            "Evade endpoint protection",
            "Bypass cloud security logging",
            "Circumvent access controls",
            "Enable persistent access",
        ],
        known_threat_actors=[],
        recent_campaigns=[],  # Populated dynamically from MITRE sync data
        prevalence="uncommon",
        trend="stable",
        severity_score=8,
        severity_reasoning=(
            "Directly compromises defensive capabilities. Successful exploitation "
            "can disable security monitoring, evade detection, and enable further attack progression."
        ),
        business_impact=[
            "Security control bypass",
            "Undetected malicious activity",
            "Compliance violations",
            "Extended attacker dwell time",
        ],
        typical_attack_phase="defense_evasion",
        often_precedes=["T1562", "T1070", "T1036"],
        often_follows=["T1190", "T1210"],
    ),
    detection_strategies=[
        DetectionStrategy(
            strategy_id="t1211-aws-guardduty-disable",
            name="AWS Security Service Tampering Detection",
            description="Detect attempts to disable or modify AWS security services.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, userIdentity.principalId, eventName, errorCode
| filter eventSource = "guardduty.amazonaws.com" or eventSource = "securityhub.amazonaws.com" or eventSource = "config.amazonaws.com"
| filter eventName like /Delete|Disable|Stop|Remove/
| filter errorCode != "AccessDenied"
| stats count(*) as attempts by userIdentity.principalId, eventName, bin(5m)
| sort attempts desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect security service tampering attempts

Parameters:
  CloudTrailLogGroup:
    Type: String
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  SecurityServiceTamperFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref CloudTrailLogGroup
      FilterPattern: '{ ($.eventSource = guardduty.amazonaws.com || $.eventSource = securityhub.amazonaws.com || $.eventSource = config.amazonaws.com) && ($.eventName = Delete* || $.eventName = Disable* || $.eventName = Stop* || $.eventName = Remove*) && $.errorCode != AccessDenied }'
      MetricTransformations:
        - MetricName: SecurityServiceTampering
          MetricNamespace: Security
          MetricValue: "1"

  SecurityTamperAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: SecurityServiceTampering
      MetricName: SecurityServiceTampering
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

  TopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics: [!Ref AlertTopic]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudWatchPublish
            Effect: Allow
            Principal:
              Service: cloudwatch.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId""",
                terraform_template="""# Detect security service tampering attempts

variable "cloudtrail_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "security-tamper-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "security_tamper" {
  name           = "security-service-tampering"
  log_group_name = var.cloudtrail_log_group
  pattern        = "{ ($.eventSource = guardduty.amazonaws.com || $.eventSource = securityhub.amazonaws.com || $.eventSource = config.amazonaws.com) && ($.eventName = Delete* || $.eventName = Disable* || $.eventName = Stop* || $.eventName = Remove*) && $.errorCode != AccessDenied }"

  metric_transformation {
    name      = "SecurityServiceTampering"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "security_tamper" {
  alarm_name          = "SecurityServiceTampering"
  metric_name         = "SecurityServiceTampering"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 1
  comparison_operator = "GreaterThanOrEqualToThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}

data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "allow_cloudwatch" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Sid       = "AllowCloudWatchPublish"
      Effect    = "Allow"
      Principal = { Service = "cloudwatch.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
      Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
      }
    }]
  })
}""",
                alert_severity="critical",
                alert_title="Security Service Tampering Detected",
                alert_description_template="Attempt to disable or modify security service by {principalId}.",
                investigation_steps=[
                    "Identify the principal performing the action",
                    "Review CloudTrail for related suspicious activity",
                    "Check if security service was successfully disabled",
                    "Verify legitimacy of the change request",
                ],
                containment_actions=[
                    "Re-enable affected security services immediately",
                    "Revoke compromised credentials",
                    "Apply SCPs to prevent security service modifications",
                    "Enable GuardDuty and Security Hub deletion protection",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Legitimate administrative changes should follow change control processes",
            detection_coverage="85% - catches direct API calls to disable services",
            evasion_considerations="Attackers with root account access may still evade",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30 minutes",
            estimated_monthly_cost="$5-10",
            prerequisites=["CloudTrail enabled with CloudWatch integration"],
        ),
        DetectionStrategy(
            strategy_id="t1211-aws-edr-process-kill",
            name="AWS Security Agent Process Termination",
            description="Detect termination of security agent processes on EC2 instances.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, instanceId, processName, action
| filter action = "PROCESS_TERMINATED"
| filter processName like /amazon-ssm-agent|amazon-cloudwatch-agent|guardduty|falcon-sensor|crowdstrike/
| stats count(*) as kills by instanceId, processName, bin(5m)
| sort kills desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect security agent termination on EC2

Parameters:
  SecurityLogGroup:
    Type: String
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  AgentTerminationFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref SecurityLogGroup
      FilterPattern: '[time, instance, process="*agent*", action="TERMINATED"]'
      MetricTransformations:
        - MetricName: SecurityAgentTerminated
          MetricNamespace: Security
          MetricValue: "1"

  AgentTerminationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: SecurityAgentTermination
      MetricName: SecurityAgentTerminated
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

  TopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics: [!Ref AlertTopic]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudWatchPublish
            Effect: Allow
            Principal:
              Service: cloudwatch.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId""",
                terraform_template="""# Detect security agent termination on EC2

variable "security_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "agent-termination-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "agent_kill" {
  name           = "security-agent-termination"
  log_group_name = var.security_log_group
  pattern        = "[time, instance, process=\"*agent*\", action=\"TERMINATED\"]"

  metric_transformation {
    name      = "SecurityAgentTerminated"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "agent_kill" {
  alarm_name          = "SecurityAgentTermination"
  metric_name         = "SecurityAgentTerminated"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 1
  comparison_operator = "GreaterThanOrEqualToThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}

data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "allow_cloudwatch" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Sid       = "AllowCloudWatchPublish"
      Effect    = "Allow"
      Principal = { Service = "cloudwatch.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
      Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
      }
    }]
  })
}""",
                alert_severity="high",
                alert_title="Security Agent Terminated",
                alert_description_template="Security agent process terminated on {instanceId}.",
                investigation_steps=[
                    "Check instance for compromise indicators",
                    "Review process execution history",
                    "Verify agent configuration and health",
                    "Check for unauthorised SSH/RDP sessions",
                ],
                containment_actions=[
                    "Isolate affected instance",
                    "Restart security agents",
                    "Review and rotate instance credentials",
                    "Enable auto-restart for critical agents",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Filter legitimate maintenance windows and updates",
            detection_coverage="60% - depends on agent logging capabilities",
            evasion_considerations="Advanced attackers may disable logging before termination",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-20",
            prerequisites=["Security agents with process monitoring enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1211-gcp-security-disable",
            name="GCP Security Service Modification Detection",
            description="Detect attempts to disable or modify GCP security services.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''protoPayload.serviceName=~"securitycenter.googleapis.com|cloudkms.googleapis.com|logging.googleapis.com"
protoPayload.methodName=~".*Disable.*|.*Delete.*|.*Remove.*"
severity="NOTICE" OR severity="WARNING"
NOT protoPayload.status.code="7"''',
                gcp_terraform_template="""# GCP: Detect security service tampering

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email_s1" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "security_tamper" {
  project = var.project_id
  name   = "security-service-tampering"
  filter = <<-EOT
    protoPayload.serviceName=~"securitycenter.googleapis.com|cloudkms.googleapis.com|logging.googleapis.com"
    protoPayload.methodName=~".*Disable.*|.*Delete.*|.*Remove.*"
    (severity="NOTICE" OR severity="WARNING")
    NOT protoPayload.status.code="7"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
  }
}

resource "google_monitoring_alert_policy" "security_tamper" {
  project      = var.project_id
  display_name = "Security Service Tampering"
  combiner     = "OR"
  conditions {
    display_name = "Tampering detected"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.security_tamper.name}\""
      duration        = "60s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0
    }
  }
  notification_channels = [google_monitoring_notification_channel.email_s1.id]
  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="critical",
                alert_title="GCP: Security Service Tampering",
                alert_description_template="Attempt to disable or modify GCP security service detected.",
                investigation_steps=[
                    "Identify the principal performing the action",
                    "Review audit logs for related activity",
                    "Verify current state of security services",
                    "Check for legitimate change requests",
                ],
                containment_actions=[
                    "Re-enable affected security services",
                    "Revoke compromised service accounts",
                    "Apply organisation policies to prevent modifications",
                    "Enable Security Command Centre notifications",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Exclude authorised administrative service accounts",
            detection_coverage="80% - catches API-based tampering",
            evasion_considerations="Requires audit logging to be enabled",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30-45 minutes",
            estimated_monthly_cost="$5-15",
            prerequisites=["Cloud Audit Logs enabled", "Security Command Centre"],
        ),
        DetectionStrategy(
            strategy_id="t1211-gcp-logging-sink-modify",
            name="GCP Logging Sink Tampering Detection",
            description="Detect modifications to Cloud Logging sinks that could evade detection.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''protoPayload.serviceName="logging.googleapis.com"
protoPayload.methodName=~"google.logging.v2.ConfigServiceV2.(DeleteSink|UpdateSink)"
severity="NOTICE"''',
                gcp_terraform_template="""# GCP: Detect logging sink tampering

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email_s2" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "sink_tamper" {
  project = var.project_id
  name   = "logging-sink-tampering"
  filter = <<-EOT
    protoPayload.serviceName="logging.googleapis.com"
    protoPayload.methodName=~"google.logging.v2.ConfigServiceV2.(DeleteSink|UpdateSink)"
    severity="NOTICE"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
  }
}

resource "google_monitoring_alert_policy" "sink_tamper" {
  project      = var.project_id
  display_name = "Logging Sink Tampering"
  combiner     = "OR"
  conditions {
    display_name = "Sink modification detected"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.sink_tamper.name}\""
      duration        = "60s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0
    }
  }
  notification_channels = [google_monitoring_notification_channel.email_s2.id]
  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="high",
                alert_title="GCP: Logging Sink Modification",
                alert_description_template="Cloud Logging sink has been modified or deleted.",
                investigation_steps=[
                    "Identify who modified the sink",
                    "Review the sink configuration changes",
                    "Check if logs are still being collected",
                    "Verify legitimacy of the change",
                ],
                containment_actions=[
                    "Restore logging sink configuration",
                    "Revoke unauthorised access",
                    "Enable sink deletion protection",
                    "Review organisation policies for logging",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Whitelist infrastructure-as-code service accounts",
            detection_coverage="75% - requires sink modification via API",
            evasion_considerations="Console-based changes are also logged",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30 minutes",
            estimated_monthly_cost="$5-10",
            prerequisites=["Cloud Audit Logs enabled"],
        ),
    ],
    recommended_order=[
        "t1211-aws-guardduty-disable",
        "t1211-gcp-security-disable",
        "t1211-aws-edr-process-kill",
        "t1211-gcp-logging-sink-modify",
    ],
    total_effort_hours=3.5,
    coverage_improvement="+25% improvement for Defense Evasion tactic",
)
