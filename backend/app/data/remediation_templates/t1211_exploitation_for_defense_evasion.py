"""
T1211 - Exploitation for Defense Evasion

Adversaries exploit system or application vulnerabilities to circumvent security
features and defensive controls. Includes exploiting security software directly.
Used by APT28, Velvet Ant.
"""

from .template_loader import (
    RemediationTemplate,
    ThreatContext,
    DetectionStrategy,
    DetectionImplementation,
    DetectionType,
    EffortLevel,
    FalsePositiveRate,
    CloudProvider,
)

TEMPLATE = RemediationTemplate(
    technique_id="T1211",
    technique_name="Exploitation for Defense Evasion",
    tactic_ids=["TA0005"],
    mitre_url="https://attack.mitre.org/techniques/T1211/",
    threat_context=ThreatContext(
        description=(
            "Adversaries exploit system or application vulnerabilities to bypass "
            "security features and defensive controls. This includes exploiting "
            "security software directly, cloud IaaS/SaaS platforms, and operating "
            "system kernels to evade detection and logging mechanisms."
        ),
        attacker_goal="Bypass security controls by exploiting vulnerabilities in defensive software",
        why_technique=[
            "Disable security monitoring",
            "Evade endpoint protection",
            "Bypass cloud security logging",
            "Circumvent access controls",
            "Enable persistent access",
        ],
        known_threat_actors=[],
        recent_campaigns=[],  # Populated dynamically from MITRE sync data
        prevalence="uncommon",
        trend="stable",
        severity_score=8,
        severity_reasoning=(
            "Directly compromises defensive capabilities. Successful exploitation "
            "can disable security monitoring, evade detection, and enable further attack progression."
        ),
        business_impact=[
            "Security control bypass",
            "Undetected malicious activity",
            "Compliance violations",
            "Extended attacker dwell time",
        ],
        typical_attack_phase="defense_evasion",
        often_precedes=["T1562", "T1070", "T1036"],
        often_follows=["T1190", "T1210"],
    ),
    detection_strategies=[
        DetectionStrategy(
            strategy_id="t1211-aws-guardduty-disable",
            name="AWS Security Service Tampering Detection",
            description="Detect attempts to disable or modify AWS security services.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, userIdentity.principalId, eventName, errorCode
| filter eventSource = "guardduty.amazonaws.com" or eventSource = "securityhub.amazonaws.com" or eventSource = "config.amazonaws.com"
| filter eventName like /Delete|Disable|Stop|Remove/
| filter errorCode != "AccessDenied"
| stats count(*) as attempts by userIdentity.principalId, eventName, bin(5m)
| sort attempts desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect security service tampering attempts

Parameters:
  CloudTrailLogGroup:
    Type: String
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  SecurityServiceTamperFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref CloudTrailLogGroup
      FilterPattern: '{ ($.eventSource = guardduty.amazonaws.com || $.eventSource = securityhub.amazonaws.com || $.eventSource = config.amazonaws.com) && ($.eventName = Delete* || $.eventName = Disable* || $.eventName = Stop* || $.eventName = Remove*) && $.errorCode != AccessDenied }'
      MetricTransformations:
        - MetricName: SecurityServiceTampering
          MetricNamespace: Security
          MetricValue: "1"

  SecurityTamperAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: SecurityServiceTampering
      MetricName: SecurityServiceTampering
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

  TopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics: [!Ref AlertTopic]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudWatchPublish
            Effect: Allow
            Principal:
              Service: cloudwatch.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId""",
                terraform_template="""# Detect security service tampering attempts

variable "cloudtrail_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "security-tamper-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "security_tamper" {
  name           = "security-service-tampering"
  log_group_name = var.cloudtrail_log_group
  pattern        = "{ ($.eventSource = guardduty.amazonaws.com || $.eventSource = securityhub.amazonaws.com || $.eventSource = config.amazonaws.com) && ($.eventName = Delete* || $.eventName = Disable* || $.eventName = Stop* || $.eventName = Remove*) && $.errorCode != AccessDenied }"

  metric_transformation {
    name      = "SecurityServiceTampering"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "security_tamper" {
  alarm_name          = "SecurityServiceTampering"
  metric_name         = "SecurityServiceTampering"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 1
  comparison_operator = "GreaterThanOrEqualToThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}

data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "allow_cloudwatch" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Sid       = "AllowCloudWatchPublish"
      Effect    = "Allow"
      Principal = { Service = "cloudwatch.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
      Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
      }
    }]
  })
}""",
                alert_severity="critical",
                alert_title="Security Service Tampering Detected",
                alert_description_template="Attempt to disable or modify security service by {principalId}.",
                investigation_steps=[
                    "Identify the principal performing the action",
                    "Review CloudTrail for related suspicious activity",
                    "Check if security service was successfully disabled",
                    "Verify legitimacy of the change request",
                ],
                containment_actions=[
                    "Re-enable affected security services immediately",
                    "Revoke compromised credentials",
                    "Apply SCPs to prevent security service modifications",
                    "Enable GuardDuty and Security Hub deletion protection",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Legitimate administrative changes should follow change control processes",
            detection_coverage="85% - catches direct API calls to disable services",
            evasion_considerations="Attackers with root account access may still evade",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30 minutes",
            estimated_monthly_cost="$5-10",
            prerequisites=["CloudTrail enabled with CloudWatch integration"],
        ),
        DetectionStrategy(
            strategy_id="t1211-aws-edr-process-kill",
            name="AWS Security Agent Process Termination",
            description="Detect termination of security agent processes on EC2 instances.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, instanceId, processName, action
| filter action = "PROCESS_TERMINATED"
| filter processName like /amazon-ssm-agent|amazon-cloudwatch-agent|guardduty|falcon-sensor|crowdstrike/
| stats count(*) as kills by instanceId, processName, bin(5m)
| sort kills desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect security agent termination on EC2

Parameters:
  SecurityLogGroup:
    Type: String
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  AgentTerminationFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref SecurityLogGroup
      FilterPattern: '[time, instance, process="*agent*", action="TERMINATED"]'
      MetricTransformations:
        - MetricName: SecurityAgentTerminated
          MetricNamespace: Security
          MetricValue: "1"

  AgentTerminationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: SecurityAgentTermination
      MetricName: SecurityAgentTerminated
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

  TopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics: [!Ref AlertTopic]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudWatchPublish
            Effect: Allow
            Principal:
              Service: cloudwatch.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId""",
                terraform_template="""# Detect security agent termination on EC2

variable "security_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "agent-termination-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "agent_kill" {
  name           = "security-agent-termination"
  log_group_name = var.security_log_group
  pattern        = "[time, instance, process=\"*agent*\", action=\"TERMINATED\"]"

  metric_transformation {
    name      = "SecurityAgentTerminated"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "agent_kill" {
  alarm_name          = "SecurityAgentTermination"
  metric_name         = "SecurityAgentTerminated"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 1
  comparison_operator = "GreaterThanOrEqualToThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}

data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "allow_cloudwatch" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Sid       = "AllowCloudWatchPublish"
      Effect    = "Allow"
      Principal = { Service = "cloudwatch.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
      Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
      }
    }]
  })
}""",
                alert_severity="high",
                alert_title="Security Agent Terminated",
                alert_description_template="Security agent process terminated on {instanceId}.",
                investigation_steps=[
                    "Check instance for compromise indicators",
                    "Review process execution history",
                    "Verify agent configuration and health",
                    "Check for unauthorised SSH/RDP sessions",
                ],
                containment_actions=[
                    "Isolate affected instance",
                    "Restart security agents",
                    "Review and rotate instance credentials",
                    "Enable auto-restart for critical agents",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Filter legitimate maintenance windows and updates",
            detection_coverage="60% - depends on agent logging capabilities",
            evasion_considerations="Advanced attackers may disable logging before termination",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-20",
            prerequisites=["Security agents with process monitoring enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1211-gcp-security-disable",
            name="GCP Security Service Modification Detection",
            description="Detect attempts to disable or modify GCP security services.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''protoPayload.serviceName=~"securitycenter.googleapis.com|cloudkms.googleapis.com|logging.googleapis.com"
protoPayload.methodName=~".*Disable.*|.*Delete.*|.*Remove.*"
severity="NOTICE" OR severity="WARNING"
NOT protoPayload.status.code="7"''',
                gcp_terraform_template="""# GCP: Detect security service tampering

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email_s1" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "security_tamper" {
  project = var.project_id
  name   = "security-service-tampering"
  filter = <<-EOT
    protoPayload.serviceName=~"securitycenter.googleapis.com|cloudkms.googleapis.com|logging.googleapis.com"
    protoPayload.methodName=~".*Disable.*|.*Delete.*|.*Remove.*"
    (severity="NOTICE" OR severity="WARNING")
    NOT protoPayload.status.code="7"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
  }
}

resource "google_monitoring_alert_policy" "security_tamper" {
  project      = var.project_id
  display_name = "Security Service Tampering"
  combiner     = "OR"
  conditions {
    display_name = "Tampering detected"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.security_tamper.name}\""
      duration        = "60s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0
    }
  }
  notification_channels = [google_monitoring_notification_channel.email_s1.id]
  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="critical",
                alert_title="GCP: Security Service Tampering",
                alert_description_template="Attempt to disable or modify GCP security service detected.",
                investigation_steps=[
                    "Identify the principal performing the action",
                    "Review audit logs for related activity",
                    "Verify current state of security services",
                    "Check for legitimate change requests",
                ],
                containment_actions=[
                    "Re-enable affected security services",
                    "Revoke compromised service accounts",
                    "Apply organisation policies to prevent modifications",
                    "Enable Security Command Centre notifications",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Exclude authorised administrative service accounts",
            detection_coverage="80% - catches API-based tampering",
            evasion_considerations="Requires audit logging to be enabled",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30-45 minutes",
            estimated_monthly_cost="$5-15",
            prerequisites=["Cloud Audit Logs enabled", "Security Command Centre"],
        ),
        DetectionStrategy(
            strategy_id="t1211-gcp-logging-sink-modify",
            name="GCP Logging Sink Tampering Detection",
            description="Detect modifications to Cloud Logging sinks that could evade detection.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''protoPayload.serviceName="logging.googleapis.com"
protoPayload.methodName=~"google.logging.v2.ConfigServiceV2.(DeleteSink|UpdateSink)"
severity="NOTICE"''',
                gcp_terraform_template="""# GCP: Detect logging sink tampering

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email_s2" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "sink_tamper" {
  project = var.project_id
  name   = "logging-sink-tampering"
  filter = <<-EOT
    protoPayload.serviceName="logging.googleapis.com"
    protoPayload.methodName=~"google.logging.v2.ConfigServiceV2.(DeleteSink|UpdateSink)"
    severity="NOTICE"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
  }
}

resource "google_monitoring_alert_policy" "sink_tamper" {
  project      = var.project_id
  display_name = "Logging Sink Tampering"
  combiner     = "OR"
  conditions {
    display_name = "Sink modification detected"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.sink_tamper.name}\""
      duration        = "60s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0
    }
  }
  notification_channels = [google_monitoring_notification_channel.email_s2.id]
  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="high",
                alert_title="GCP: Logging Sink Modification",
                alert_description_template="Cloud Logging sink has been modified or deleted.",
                investigation_steps=[
                    "Identify who modified the sink",
                    "Review the sink configuration changes",
                    "Check if logs are still being collected",
                    "Verify legitimacy of the change",
                ],
                containment_actions=[
                    "Restore logging sink configuration",
                    "Revoke unauthorised access",
                    "Enable sink deletion protection",
                    "Review organisation policies for logging",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Whitelist infrastructure-as-code service accounts",
            detection_coverage="75% - requires sink modification via API",
            evasion_considerations="Console-based changes are also logged",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30 minutes",
            estimated_monthly_cost="$5-10",
            prerequisites=["Cloud Audit Logs enabled"],
        ),
        # Azure Strategy: Exploitation for Defense Evasion
        DetectionStrategy(
            strategy_id="t1211-azure",
            name="Azure Exploitation for Defense Evasion Detection",
            description=(
                "Azure detection for Exploitation for Defense Evasion. "
                "Provides native Azure detection using Log Analytics and Defender for Cloud."
            ),
            detection_type=DetectionType.SENTINEL_RULE,
            aws_service="n/a",
            azure_service="sentinel",
            cloud_provider=CloudProvider.AZURE,
            implementation=DetectionImplementation(
                sentinel_rule_query="""// Sentinel Analytics Rule: Exploitation for Defense Evasion
// MITRE ATT&CK: T1211
let lookback = 24h;
let threshold = 5;
AzureActivity
| where TimeGenerated > ago(lookback)
| where CategoryValue == "Administrative"
| where ActivityStatusValue in ("Success", "Succeeded")
| summarize
    EventCount = count(),
    DistinctOperations = dcount(OperationNameValue),
    Operations = make_set(OperationNameValue, 20),
    Resources = make_set(Resource, 10),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated)
    by Caller, CallerIpAddress, SubscriptionId
| where EventCount > threshold
| extend
    AccountName = tostring(split(Caller, "@")[0]),
    AccountDomain = tostring(split(Caller, "@")[1])
| project
    TimeGenerated = LastSeen,
    AccountName,
    AccountDomain,
    Caller,
    CallerIpAddress,
    SubscriptionId,
    EventCount,
    DistinctOperations,
    Operations,
    Resources""",
                azure_terraform_template="""# Azure Detection for Exploitation for Defense Evasion
# MITRE ATT&CK: T1211

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = ">= 3.0"
    }
  }
}

variable "resource_group_name" {
  type        = string
  description = "Resource group for Log Analytics workspace"
}

variable "log_analytics_workspace_id" {
  type        = string
  description = "Log Analytics workspace resource ID"
}

variable "alert_email" {
  type        = string
  description = "Email for security alerts"
}

# Action Group for alerts
resource "azurerm_monitor_action_group" "security_alerts" {
  name                = "exploitation-for-defense-evasion-alerts"
  resource_group_name = var.resource_group_name
  short_name          = "SecAlerts"

  email_receiver {
    name          = "security-team"
    email_address = var.alert_email
  }
}

# Scheduled Query Rule for detection
resource "azurerm_monitor_scheduled_query_rules_alert_v2" "detection" {
  name                = "exploitation-for-defense-evasion-detection"
  resource_group_name = var.resource_group_name
  location            = "uksouth"

  evaluation_frequency = "PT5M"
  window_duration      = "PT1H"
  scopes               = [var.log_analytics_workspace_id]
  severity             = 2

  criteria {
    query = <<-QUERY
// Sentinel Analytics Rule: Exploitation for Defense Evasion
// MITRE ATT&CK: T1211
let lookback = 24h;
let threshold = 5;
AzureActivity
| where TimeGenerated > ago(lookback)
| where CategoryValue == "Administrative"
| where ActivityStatusValue in ("Success", "Succeeded")
| summarize
    EventCount = count(),
    DistinctOperations = dcount(OperationNameValue),
    Operations = make_set(OperationNameValue, 20),
    Resources = make_set(Resource, 10),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated)
    by Caller, CallerIpAddress, SubscriptionId
| where EventCount > threshold
| extend
    AccountName = tostring(split(Caller, "@")[0]),
    AccountDomain = tostring(split(Caller, "@")[1])
| project
    TimeGenerated = LastSeen,
    AccountName,
    AccountDomain,
    Caller,
    CallerIpAddress,
    SubscriptionId,
    EventCount,
    DistinctOperations,
    Operations,
    Resources
    QUERY

    time_aggregation_method = "Count"
    threshold               = 1
    operator                = "GreaterThanOrEqual"

    failing_periods {
      minimum_failing_periods_to_trigger_alert = 1
      number_of_evaluation_periods             = 1
    }
  }

  auto_mitigation_enabled = false

  action {
    action_groups = [azurerm_monitor_action_group.security_alerts.id]
  }

  description = "Detects Exploitation for Defense Evasion (T1211) activity in Azure environment"
  display_name = "Exploitation for Defense Evasion Detection"
  enabled      = true

  tags = {
    "mitre-technique" = "T1211"
    "detection-type"  = "security"
  }
}

output "alert_rule_id" {
  value = azurerm_monitor_scheduled_query_rules_alert_v2.detection.id
}""",
                alert_severity="high",
                alert_title="Azure: Exploitation for Defense Evasion Detected",
                alert_description_template=(
                    "Exploitation for Defense Evasion activity detected. "
                    "Caller: {Caller}. Resource: {Resource}."
                ),
                investigation_steps=[
                    "Review Azure Activity Log for full operation details",
                    "Check caller identity and verify if authorised",
                    "Review affected resources and assess impact",
                    "Check for related activities in the same time window",
                    "Verify against change management records",
                ],
                containment_actions=[
                    "Disable compromised user/service principal if unauthorised",
                    "Revoke active sessions using Entra ID",
                    "Review and restrict Azure RBAC permissions",
                    "Enable additional Defender for Cloud protections",
                    "Implement Azure Policy to prevent recurrence",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning=(
                "Allowlist known automation accounts and CI/CD service principals. "
                "Use Azure Policy to define expected behaviour baselines."
            ),
            detection_coverage="70% - Azure-native detection for cloud operations",
            evasion_considerations=(
                "Attackers may use legitimate credentials from expected locations. "
                "Combine with Defender for Cloud for ML-based anomaly detection."
            ),
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-50 (Log Analytics + Defender)",
            prerequisites=[
                "Azure subscription with Log Analytics workspace",
                "Defender for Cloud enabled (recommended)",
                "Appropriate Azure RBAC permissions for deployment",
            ],
        ),
    ],
    recommended_order=[
        "t1211-aws-guardduty-disable",
        "t1211-gcp-security-disable",
        "t1211-aws-edr-process-kill",
        "t1211-gcp-logging-sink-modify",
    ],
    total_effort_hours=3.5,
    coverage_improvement="+25% improvement for Defense Evasion tactic",
)
