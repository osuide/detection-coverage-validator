"""
T1068 - Exploitation for Privilege Escalation

Adversaries exploit software vulnerabilities to escalate privileges on compromised systems,
moving from unprivileged access to SYSTEM/root. Includes BYOVD attacks and container escapes.
Used by APT28, APT29, APT32, Turla, Volt Typhoon, FIN6, FIN8.
"""

from .template_loader import (
    RemediationTemplate,
    ThreatContext,
    DetectionStrategy,
    DetectionImplementation,
    DetectionType,
    EffortLevel,
    FalsePositiveRate,
    CloudProvider,
)

TEMPLATE = RemediationTemplate(
    technique_id="T1068",
    technique_name="Exploitation for Privilege Escalation",
    tactic_ids=["TA0004"],
    mitre_url="https://attack.mitre.org/techniques/T1068/",
    threat_context=ThreatContext(
        description=(
            "Adversaries exploit software vulnerabilities in operating systems and applications "
            "to elevate privileges from unprivileged user-level access to SYSTEM or root. "
            "This includes exploiting kernel vulnerabilities, vulnerable drivers (BYOVD), "
            "container escapes, and hypervisor breakouts. Common in cloud environments "
            "for escaping container isolation and accessing underlying hosts."
        ),
        attacker_goal="Escalate privileges to SYSTEM/root level for full system control",
        why_technique=[
            "Bypass security controls requiring elevated permissions",
            "Achieve persistence at system level",
            "Disable security software",
            "Escape container/VM isolation",
            "Access sensitive credentials and data",
            "BYOVD tactics bypass modern protections",
        ],
        known_threat_actors=[],
        recent_campaigns=[],  # Populated dynamically from MITRE sync data
        prevalence="common",
        trend="increasing",
        severity_score=8,
        severity_reasoning=(
            "Critical post-compromise technique enabling full system control. "
            "BYOVD attacks bypass modern protections. Container escapes expose "
            "cloud infrastructure. Often precedes persistence and lateral movement."
        ),
        business_impact=[
            "Full system compromise",
            "Security control bypass",
            "Data exfiltration enabler",
            "Ransomware deployment",
            "Container/VM escape in cloud",
            "Hypervisor-level compromise",
        ],
        typical_attack_phase="privilege_escalation",
        often_precedes=["T1053", "T1543", "T1136", "T1078"],
        often_follows=["T1190", "T1078", "T1566"],
    ),
    detection_strategies=[
        DetectionStrategy(
            strategy_id="t1068-aws-guardduty",
            name="AWS GuardDuty Privilege Escalation Detection",
            description="Detect privilege escalation attempts via GuardDuty findings.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="guardduty",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, detail.type, detail.resource.instanceDetails.instanceId, detail.severity
| filter detail.type like /PrivilegeEscalation|Runtime:EC2|Execution:Runtime/
| filter detail.type like /SuspiciousFile|PrivilegedContainer|ReverseShell|ModifiedBinaryFile/
| stats count(*) as findings by detail.type, detail.resource.instanceDetails.instanceId, bin(1h)
| sort findings desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect privilege escalation attempts via GuardDuty

Parameters:
  AlertEmail:
    Type: String
    Description: Email address for security alerts

Resources:
  # SNS topic for alerts
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      DisplayName: Privilege Escalation Alerts
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  # Dead Letter Queue for failed deliveries
  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: guardduty-privesc-alerts-dlq
      MessageRetentionPeriod: 1209600

  # EventBridge rule for GuardDuty privilege escalation findings
  PrivEscRule:
    Type: AWS::Events::Rule
    Properties:
      Name: GuardDuty-PrivilegeEscalation
      Description: Alert on privilege escalation findings
      EventPattern:
        source:
          - aws.guardduty
        detail-type:
          - GuardDuty Finding
        detail:
          type:
            - prefix: PrivilegeEscalation
            - prefix: Runtime:EC2
            - prefix: Execution:Runtime
      State: ENABLED
      Targets:
        - Arn: !Ref AlertTopic
          Id: SNSTarget
          RetryPolicy:
            MaximumEventAgeInSeconds: 3600
            MaximumRetryAttempts: 8
          DeadLetterConfig:
            Arn: !GetAtt DeadLetterQueue.Arn
          InputTransformer:
            InputPathsMap:
              account: $.account
              region: $.region
              time: $.time
              type: $.detail.type
              severity: $.detail.severity
              instanceId: $.detail.resource.instanceDetails.instanceId
            InputTemplate: |
              "GuardDuty Privilege Escalation Alert (T1068)"
              "Time: <time>"
              "Account: <account> | Region: <region>"
              "Finding Type: <type>"
              "Severity: <severity>"
              "Instance: <instanceId>"
              "Action: Investigate privilege escalation immediately"

  # Allow EventBridge to publish to SNS
  SNSTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics:
        - !Ref AlertTopic
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowEventBridgePublishScoped
            Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId
              ArnEquals:
                aws:SourceArn: !GetAtt PrivEscRule.Arn

  DLQPolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref DeadLetterQueue
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sqs:SendMessage
            Resource: !GetAtt DeadLetterQueue.Arn
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId
              ArnEquals:
                aws:SourceArn: !GetAtt PrivEscRule.Arn""",
                terraform_template="""# Detect privilege escalation via GuardDuty

variable "alert_email" {
  type        = string
  description = "Email for security alerts"
}

data "aws_caller_identity" "current" {}

# SNS topic for alerts
resource "aws_sns_topic" "alerts" {
  name              = "privilege-escalation-alerts"
  kms_master_key_id = "alias/aws/sns"
  display_name      = "Privilege Escalation Alerts"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Dead Letter Queue for failed deliveries
resource "aws_sqs_queue" "dlq" {
  name                      = "guardduty-privesc-alerts-dlq"
  message_retention_seconds = 1209600
}

# EventBridge rule for GuardDuty findings
resource "aws_cloudwatch_event_rule" "privesc" {
  name        = "guardduty-privilege-escalation"
  description = "Alert on privilege escalation findings"

  event_pattern = jsonencode({
    source        = ["aws.guardduty"]
    "detail-type" = ["GuardDuty Finding"]
    detail = {
      type = [
        { prefix = "PrivilegeEscalation" },
        { prefix = "Runtime:EC2" },
        { prefix = "Execution:Runtime" }
      ]
    }
  })
}

resource "aws_cloudwatch_event_target" "sns" {
  rule      = aws_cloudwatch_event_rule.privesc.name
  target_id = "SNSTarget"
  arn       = aws_sns_topic.alerts.arn

  retry_policy {
    maximum_event_age_in_seconds = 3600
    maximum_retry_attempts       = 8
  }

  dead_letter_config {
    arn = aws_sqs_queue.dlq.arn
  }

  input_transformer {
    input_paths = {
      account    = "$.account"
      region     = "$.region"
      time       = "$.time"
      type       = "$.detail.type"
      severity   = "$.detail.severity"
      instanceId = "$.detail.resource.instanceDetails.instanceId"
    }

    input_template = <<-EOT
"GuardDuty Privilege Escalation Alert (T1068)
Time: <time>
Account: <account> | Region: <region>
Finding Type: <type>
Severity: <severity>
Instance: <instanceId>
Action: Investigate privilege escalation immediately"
EOT
  }
}

# SNS topic policy with scoped conditions
resource "aws_sns_topic_policy" "alerts" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Sid       = "AllowEventBridgePublishScoped"
      Effect    = "Allow"
      Principal = { Service = "events.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
      Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
        ArnEquals = {
          "aws:SourceArn" = aws_cloudwatch_event_rule.privesc.arn
        }
      }
    }]
  })
}

resource "aws_sqs_queue_policy" "dlq" {
  queue_url = aws_sqs_queue.dlq.id
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect    = "Allow"
      Principal = { Service = "events.amazonaws.com" }
      Action    = "sqs:SendMessage"
      Resource  = aws_sqs_queue.dlq.arn
    }]
  })
}""",
                alert_severity="critical",
                alert_title="Privilege Escalation Attempt Detected",
                alert_description_template="GuardDuty detected privilege escalation on instance {instanceId}.",
                investigation_steps=[
                    "Review GuardDuty finding details",
                    "Check instance CloudTrail logs",
                    "Review running processes and services",
                    "Check for kernel module loads",
                    "Verify installed drivers and software",
                    "Review user privilege changes",
                ],
                containment_actions=[
                    "Isolate affected instance",
                    "Snapshot instance for forensics",
                    "Review and revoke elevated permissions",
                    "Check for persistence mechanisms",
                    "Patch vulnerable software",
                    "Review security group rules",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="GuardDuty findings are generally reliable, tune for legitimate admin activities",
            detection_coverage="60% - catches runtime exploitation attempts",
            evasion_considerations="Sophisticated BYOVD attacks may evade detection",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30 minutes",
            estimated_monthly_cost="$5-15",
            prerequisites=["AWS GuardDuty enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1068-aws-kernel-module",
            name="AWS CloudWatch Kernel Module Loading",
            description="Detect suspicious kernel module loads that may indicate privilege escalation.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, @message
| filter @message like /insmod|modprobe|kmod/
| filter @message not like /systemd|udev|NetworkManager/
| parse @message /(?<user>\\S+)\\s+.*\\s+(?<command>insmod|modprobe)\\s+(?<module>\\S+)/
| stats count(*) as loads by user, module, bin(5m)
| sort loads desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect suspicious kernel module loading

Parameters:
  LogGroup:
    Type: String
    Description: CloudWatch Log Group for system logs
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  # Metric filter for kernel module loads
  KernelModuleFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref LogGroup
      FilterPattern: '[time, host, user, ..., command=*insmod* || command=*modprobe*]'
      MetricTransformations:
        - MetricName: KernelModuleLoads
          MetricNamespace: Security
          MetricValue: "1"

  # Alarm for suspicious kernel module activity
  KernelModuleAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: SuspiciousKernelModuleLoads
      MetricName: KernelModuleLoads
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]""",
                terraform_template="""# Detect suspicious kernel module loading

variable "log_group" {
  type        = string
  description = "CloudWatch Log Group for system logs"
}

variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "kernel-module-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "kernel_modules" {
  name           = "kernel-module-loads"
  log_group_name = var.log_group
  pattern        = "[time, host, user, ..., command=*insmod* || command=*modprobe*]"

  metric_transformation {
    name      = "KernelModuleLoads"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "kernel_modules" {
  alarm_name          = "SuspiciousKernelModuleLoads"
  metric_name         = "KernelModuleLoads"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 5
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}""",
                alert_severity="high",
                alert_title="Suspicious Kernel Module Loading",
                alert_description_template="Unusual kernel module loading detected on {host}.",
                investigation_steps=[
                    "Identify loaded kernel module",
                    "Check module signature and origin",
                    "Review user context and privileges",
                    "Check for known vulnerable drivers",
                    "Review system call traces",
                    "Check for BYOVD indicators",
                ],
                containment_actions=[
                    "Unload suspicious modules",
                    "Block module loading",
                    "Isolate affected systems",
                    "Review driver allowlist",
                    "Update kernel and drivers",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Exclude legitimate system modules and admin activities",
            detection_coverage="50% - catches kernel-level exploitation",
            evasion_considerations="Attackers may use in-memory techniques",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-10",
            prerequisites=["CloudWatch Logs agent with system logs"],
        ),
        DetectionStrategy(
            strategy_id="t1068-aws-container-escape",
            name="AWS Container Escape Detection",
            description="Detect container escape attempts in ECS/EKS environments.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, @message
| filter @message like /docker|containerd|runc|nsenter|privileged/
| filter @message like /proc.*root|sys.*devices|mount.*propagation|cap_sys_admin/
| parse @message /(?<user>\\S+)\\s+.*\\s+(?<suspicious_action>nsenter|unshare|pivot_root|mount.*--bind)/
| stats count(*) as attempts by user, suspicious_action, bin(5m)
| filter attempts > 0
| sort attempts desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect container escape attempts

Parameters:
  ContainerLogGroup:
    Type: String
    Description: CloudWatch Log Group for container logs
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  # Metric filter for container escape indicators
  ContainerEscapeFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref ContainerLogGroup
      FilterPattern: '[..., action=*nsenter* || action=*unshare* || action=*pivot_root*]'
      MetricTransformations:
        - MetricName: ContainerEscapeAttempts
          MetricNamespace: Security
          MetricValue: "1"

  # Alarm for container escape attempts
  ContainerEscapeAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: ContainerEscapeDetected
      MetricName: ContainerEscapeAttempts
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 1
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

  TopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics:
        - !Ref AlertTopic
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudWatchPublishScoped
            Effect: Allow
            Principal:
              Service: cloudwatch.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId""",
                terraform_template="""# Detect container escape attempts

variable "container_log_group" {
  type        = string
  description = "CloudWatch Log Group for containers"
}

variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "container-escape-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "container_escape" {
  name           = "container-escape-attempts"
  log_group_name = var.container_log_group
  pattern        = "[..., action=*nsenter* || action=*unshare* || action=*pivot_root*]"

  metric_transformation {
    name      = "ContainerEscapeAttempts"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "container_escape" {
  alarm_name          = "ContainerEscapeDetected"
  metric_name         = "ContainerEscapeAttempts"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 1
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions = [aws_sns_topic.alerts.arn]
}

data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "alerts" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Sid       = "AllowCloudWatchPublishScoped"
      Effect    = "Allow"
      Principal = { Service = "cloudwatch.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
      Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
      }
    }]
  })
}""",
                alert_severity="critical",
                alert_title="Container Escape Attempt Detected",
                alert_description_template="Container escape attempt detected in {container}.",
                investigation_steps=[
                    "Review container configuration",
                    "Check for privileged containers",
                    "Review mounted volumes",
                    "Check container capabilities",
                    "Review network namespace access",
                    "Check for CVE-2019-5736 or similar exploits",
                ],
                containment_actions=[
                    "Stop affected containers",
                    "Review pod security policies",
                    "Remove privileged container access",
                    "Update container runtime",
                    "Isolate affected nodes",
                    "Review and restrict capabilities",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Very few legitimate uses of these commands in containers",
            detection_coverage="55% - catches common escape techniques",
            evasion_considerations="Novel exploits may not trigger patterns",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-15",
            prerequisites=["ECS/EKS with CloudWatch Container Insights"],
        ),
        DetectionStrategy(
            strategy_id="t1068-gcp-audit-privesc",
            name="GCP Privilege Escalation via Audit Logs",
            description="Detect privilege escalation attempts via GCP Audit Logs.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''protoPayload.methodName=~"setIamPolicy|setServiceAccount|addServiceAccount"
severity="ERROR"
OR (protoPayload.methodName=~"compute.instances.setMetadata"
    protoPayload.request.items.key="startup-script")
OR protoPayload.authorizationInfo.permission=~"iam.serviceAccounts.actAs|iam.serviceAccountKeys.create"''',
                gcp_terraform_template="""# GCP: Detect privilege escalation attempts

variable "project_id" { type = string }
variable "alert_email" { type = string }

# Notification channel
resource "google_monitoring_notification_channel" "email" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels = {
    email_address = var.alert_email
  }
}

# Log metric for privilege escalation
resource "google_logging_metric" "privesc_attempts" {
  project = var.project_id
  name   = "privilege-escalation-attempts"
  filter = <<-EOT
    protoPayload.methodName=~"setIamPolicy|setServiceAccount|addServiceAccount"
    severity="ERROR"
    OR (protoPayload.methodName=~"compute.instances.setMetadata"
        protoPayload.request.items.key="startup-script")
    OR protoPayload.authorizationInfo.permission=~"iam.serviceAccounts.actAs|iam.serviceAccountKeys.create"
  EOT

  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
    labels {
      key         = "principal"
      value_type  = "STRING"
      description = "User attempting escalation"
    }
  }

  label_extractors = {
    "principal" = "EXTRACT(protoPayload.authenticationInfo.principalEmail)"
  }
}

# Alert policy for privilege escalation
resource "google_monitoring_alert_policy" "privesc" {
  project      = var.project_id
  display_name = "Privilege Escalation Detected"
  combiner     = "OR"

  conditions {
    display_name = "Privilege escalation attempts"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.privesc_attempts.name}\""
      duration        = "60s"
      comparison      = "COMPARISON_GT"
      threshold_value = 3
      aggregations {
        alignment_period   = "60s"
        per_series_aligner = "ALIGN_RATE"
      }
    }
  }

  notification_channels = [google_monitoring_notification_channel.email.id]

  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="critical",
                alert_title="GCP: Privilege Escalation Attempt",
                alert_description_template="Privilege escalation attempt by {principal}.",
                investigation_steps=[
                    "Review IAM policy changes",
                    "Check service account modifications",
                    "Review instance metadata changes",
                    "Check for unauthorized key creation",
                    "Review Cloud Audit Logs",
                    "Verify user permissions and MFA",
                ],
                containment_actions=[
                    "Revoke elevated permissions",
                    "Disable compromised service accounts",
                    "Reset instance metadata",
                    "Delete unauthorized keys",
                    "Review and restrict IAM bindings",
                    "Enable organisation policy constraints",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Filter out legitimate admin changes via service accounts",
            detection_coverage="65% - catches IAM-based escalation",
            evasion_considerations="Attackers may use existing elevated permissions",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-20",
            prerequisites=["GCP Cloud Audit Logs enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1068-gcp-container-escape",
            name="GCP GKE Container Escape Detection",
            description="Detect container escape attempts in GKE environments.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query="""resource.type="k8s_container"
(jsonPayload.message=~"nsenter|unshare|pivot_root|mount.*bind"
 OR protoPayload.request.spec.containers.securityContext.privileged=true
 OR protoPayload.request.spec.hostNetwork=true
 OR protoPayload.request.spec.hostPID=true)""",
                gcp_terraform_template="""# GCP: Detect GKE container escape attempts

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels = {
    email_address = var.alert_email
  }
}

# Log metric for container escape
resource "google_logging_metric" "container_escape" {
  project = var.project_id
  name   = "gke-container-escape"
  filter = <<-EOT
    resource.type="k8s_container"
    (jsonPayload.message=~"nsenter|unshare|pivot_root|mount.*bind"
     OR protoPayload.request.spec.containers.securityContext.privileged=true
     OR protoPayload.request.spec.hostNetwork=true
     OR protoPayload.request.spec.hostPID=true)
  EOT

  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
  }
}

# Alert for container escape
resource "google_monitoring_alert_policy" "container_escape" {
  project      = var.project_id
  display_name = "GKE Container Escape Detected"
  combiner     = "OR"

  conditions {
    display_name = "Container escape attempt"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.container_escape.name}\""
      duration        = "60s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0
      aggregations {
        alignment_period   = "60s"
        per_series_aligner = "ALIGN_RATE"
      }
    }
  }

  notification_channels = [google_monitoring_notification_channel.email.id]

  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="critical",
                alert_title="GCP: GKE Container Escape Attempt",
                alert_description_template="Container escape attempt detected in GKE cluster.",
                investigation_steps=[
                    "Review pod security policies",
                    "Check for privileged containers",
                    "Review host namespace access",
                    "Check container capabilities",
                    "Review GKE audit logs",
                    "Check for vulnerable container runtime",
                ],
                containment_actions=[
                    "Delete affected pods",
                    "Enable Pod Security Standards",
                    "Remove privileged access",
                    "Update container runtime",
                    "Isolate affected nodes",
                    "Review and restrict capabilities",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Few legitimate uses in production GKE",
            detection_coverage="60% - catches common escape patterns",
            evasion_considerations="Novel exploits may bypass detection",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-20",
            prerequisites=["GKE with Cloud Logging enabled"],
        ),
    ],
    recommended_order=[
        "t1068-aws-guardduty",
        "t1068-gcp-audit-privesc",
        "t1068-aws-container-escape",
        "t1068-gcp-container-escape",
        "t1068-aws-kernel-module",
    ],
    total_effort_hours=7.5,
    coverage_improvement="+25% improvement for Privilege Escalation tactic",
)
