"""
T1190 - Exploit Public-Facing Application

Adversaries exploit vulnerabilities in internet-facing applications to gain
initial access. Includes web apps, APIs, and cloud services.
Used by APT28, APT29, APT41, HAFNIUM.
"""

from .template_loader import (
    RemediationTemplate,
    ThreatContext,
    DetectionStrategy,
    DetectionImplementation,
    DetectionType,
    EffortLevel,
    FalsePositiveRate,
    CloudProvider,
)

TEMPLATE = RemediationTemplate(
    technique_id="T1190",
    technique_name="Exploit Public-Facing Application",
    tactic_ids=["TA0001"],
    mitre_url="https://attack.mitre.org/techniques/T1190/",
    threat_context=ThreatContext(
        description=(
            "Adversaries exploit vulnerabilities in internet-facing applications "
            "including web apps, APIs, databases, and cloud services. Can lead to "
            "access to underlying instances or metadata services. Modern attacks include "
            "SSRF targeting IMDS, DDoS attacks, and API exploitation."
        ),
        attacker_goal="Gain initial access by exploiting public-facing application vulnerabilities",
        why_technique=[
            "Direct path to internal network",
            "Many known CVEs available",
            "Automated exploitation tools exist",
            "Cloud apps expose metadata services (IMDS)",
            "Often unpatched systems",
            "API endpoints frequently lack rate limiting",
            "DDoS can expose secondary vulnerabilities",
        ],
        known_threat_actors=[],
        recent_campaigns=[],  # Populated dynamically from MITRE sync data
        prevalence="common",
        trend="increasing",
        severity_score=9,
        severity_reasoning=(
            "Direct initial access technique. Successful exploitation can lead to "
            "full system compromise and access to cloud metadata/credentials. SSRF attacks "
            "targeting IMDS can expose IAM credentials. DDoS attacks can mask exploitation attempts."
        ),
        business_impact=[
            "Initial network compromise",
            "Data breach risk",
            "Lateral movement enabler",
            "Cloud credential theft via IMDS",
            "Service disruption via DDoS",
            "Regulatory compliance violations",
        ],
        typical_attack_phase="initial_access",
        often_precedes=["T1078.004", "T1552.005", "T1530"],
        often_follows=[],
    ),
    detection_strategies=[
        DetectionStrategy(
            strategy_id="t1190-aws-waf-managed-common",
            name="AWS WAF Managed Rules - Common Rule Set",
            description="Deploy AWS Managed Rules Common Rule Set to protect against OWASP Top 10 and common exploits.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="waf",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Deploy AWS WAF with AWSManagedRulesCommonRuleSet for OWASP Top 10 protection

Parameters:
  WebACLName:
    Type: String
    Default: exploit-protection-webacl
  AlertEmail:
    Type: String

Resources:
  # Step 1: Create encrypted SNS topic for alerts
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  # Step 2: Create WAF with Managed Common Rule Set (700 WCU)
  WebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: !Ref WebACLName
      Scope: REGIONAL
      DefaultAction:
        Allow: {}
      Rules:
        - Name: AWSManagedRulesCommonRuleSet
          Priority: 0
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
          OverrideAction:
            None: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: CommonRuleSetMetric
      VisibilityConfig:
        SampledRequestsEnabled: true
        CloudWatchMetricsEnabled: true
        MetricName: !Ref WebACLName

  # Step 3: Alert on blocked requests
  WAFBlockAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: WAF-CommonRuleSet-Blocks
      MetricName: BlockedRequests
      Namespace: AWS/WAFV2
      Dimensions:
        - Name: WebACL
          Value: !Ref WebACLName
        - Name: Rule
          Value: AWSManagedRulesCommonRuleSet
        - Name: Region
          Value: !Ref AWS::Region
      Statistic: Sum
      Period: 300
      Threshold: 100
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]""",
                terraform_template="""# Deploy AWS WAF with AWSManagedRulesCommonRuleSet for OWASP Top 10 protection

variable "web_acl_name" {
  type    = string
  default = "exploit-protection-webacl"
}

variable "alert_email" {
  type = string
}

# Step 1: Create encrypted SNS topic for alerts
resource "aws_sns_topic" "waf_alerts" {
  name              = "waf-common-ruleset-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.waf_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Step 2: Create WAF with Managed Common Rule Set (700 WCU)
resource "aws_wafv2_web_acl" "main" {
  name  = var.web_acl_name
  scope = "REGIONAL"

  default_action {
    allow {}
  }

  rule {
    name     = "AWSManagedRulesCommonRuleSet"
    priority = 0

    statement {
      managed_rule_group_statement {
        vendor_name = "AWS"
        name        = "AWSManagedRulesCommonRuleSet"
      }
    }

    override_action {
      none {}
    }

    visibility_config {
      sampled_requests_enabled   = true
      cloudwatch_metrics_enabled = true
      metric_name                = "CommonRuleSetMetric"
    }
  }

  visibility_config {
    sampled_requests_enabled   = true
    cloudwatch_metrics_enabled = true
    metric_name                = var.web_acl_name
  }
}

# Step 3: Alert on blocked requests
resource "aws_cloudwatch_metric_alarm" "waf_blocks" {
  alarm_name          = "WAF-CommonRuleSet-Blocks"
  metric_name         = "BlockedRequests"
  namespace           = "AWS/WAFV2"
  statistic           = "Sum"
  period              = 300
  threshold           = 100
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1

  dimensions = {
    WebACL = var.web_acl_name
    Rule   = "AWSManagedRulesCommonRuleSet"
    Region = data.aws_region.current.name
  }

  treat_missing_data = "notBreaching"
  alarm_actions      = [aws_sns_topic.waf_alerts.arn]
}

data "aws_region" "current" {}""",
                alert_severity="high",
                alert_title="WAF Common Rule Set Blocking Exploitation Attempts",
                alert_description_template="AWS WAF blocked {count} requests matching OWASP Top 10 patterns.",
                investigation_steps=[
                    "Review blocked request patterns in WAF logs",
                    "Identify source IPs and request signatures",
                    "Check if same IPs have successful requests",
                    "Correlate with application logs for bypass attempts",
                    "Review specific rule IDs that triggered blocks",
                ],
                containment_actions=[
                    "Add IP-based rate limiting for repeat offenders",
                    "Enable additional WAF managed rule groups",
                    "Review application for vulnerabilities",
                    "Consider upgrading to AWS Shield Advanced",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Use count mode initially to baseline, then switch to block mode",
            detection_coverage="75% - OWASP Top 10 coverage",
            evasion_considerations="Novel zero-day exploits, obfuscated payloads",
            implementation_effort=EffortLevel.LOW,
            implementation_time="1 hour",
            estimated_monthly_cost="$5-15 (WAF rules) + $1 per million requests",
            prerequisites=["ALB, API Gateway, or CloudFront distribution"],
        ),
        DetectionStrategy(
            strategy_id="t1190-aws-waf-comprehensive",
            name="AWS WAF Comprehensive Managed Rule Groups",
            description="Deploy comprehensive AWS Managed Rule Groups including SQLi, Linux/Unix, and Known Bad Inputs protection.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="waf",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Deploy comprehensive AWS WAF protection with multiple managed rule groups

Parameters:
  WebACLName:
    Type: String
    Default: comprehensive-waf-protection
  AlertEmail:
    Type: String

Resources:
  # Step 1: Create encrypted SNS topic with DLQ
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      MessageRetentionPeriod: 1209600  # 14 days
      KmsMasterKeyId: alias/aws/sqs

  # Step 2: Create comprehensive WAF WebACL with multiple rule groups
  WebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: !Ref WebACLName
      Scope: REGIONAL
      DefaultAction:
        Allow: {}
      Rules:
        # SQLi Protection (200 WCU)
        - Name: AWSManagedRulesSQLiRuleSet
          Priority: 1
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesSQLiRuleSet
          OverrideAction:
            None: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: SQLiRuleSetMetric

        # Known Bad Inputs (200 WCU)
        - Name: AWSManagedRulesKnownBadInputsRuleSet
          Priority: 2
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesKnownBadInputsRuleSet
          OverrideAction:
            None: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: BadInputsMetric

        # Linux Operating System Protection (200 WCU)
        - Name: AWSManagedRulesLinuxRuleSet
          Priority: 3
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesLinuxRuleSet
          OverrideAction:
            None: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: LinuxRuleSetMetric

        # Unix Operating System Protection (100 WCU)
        - Name: AWSManagedRulesUnixRuleSet
          Priority: 4
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesUnixRuleSet
          OverrideAction:
            None: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: UnixRuleSetMetric

      VisibilityConfig:
        SampledRequestsEnabled: true
        CloudWatchMetricsEnabled: true
        MetricName: !Ref WebACLName

  # Step 3: CloudWatch Alarms for each rule group
  SQLiBlockAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: WAF-SQLi-Attack-Detected
      AlarmDescription: SQL injection attacks detected by WAF
      MetricName: BlockedRequests
      Namespace: AWS/WAFV2
      Dimensions:
        - Name: WebACL
          Value: !Ref WebACLName
        - Name: Rule
          Value: AWSManagedRulesSQLiRuleSet
        - Name: Region
          Value: !Ref AWS::Region
      Statistic: Sum
      Period: 300
      Threshold: 10
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

  LinuxExploitAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: WAF-Linux-Exploit-Detected
      AlarmDescription: Linux OS exploitation attempts detected
      MetricName: BlockedRequests
      Namespace: AWS/WAFV2
      Dimensions:
        - Name: WebACL
          Value: !Ref WebACLName
        - Name: Rule
          Value: AWSManagedRulesLinuxRuleSet
        - Name: Region
          Value: !Ref AWS::Region
      Statistic: Sum
      Period: 300
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

  BadInputsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: WAF-BadInputs-Detected
      AlarmDescription: Known bad input patterns detected
      MetricName: BlockedRequests
      Namespace: AWS/WAFV2
      Dimensions:
        - Name: WebACL
          Value: !Ref WebACLName
        - Name: Rule
          Value: AWSManagedRulesKnownBadInputsRuleSet
        - Name: Region
          Value: !Ref AWS::Region
      Statistic: Sum
      Period: 300
      Threshold: 20
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]

Outputs:
  WebACLArn:
    Description: ARN of the WAF WebACL
    Value: !GetAtt WebACL.Arn
  TotalWCU:
    Description: Total WCU consumed
    Value: "700 WCU (SQLi:200 + BadInputs:200 + Linux:200 + Unix:100)""",
                terraform_template="""# Deploy comprehensive AWS WAF protection with multiple managed rule groups

variable "web_acl_name" {
  type    = string
  default = "comprehensive-waf-protection"
}

variable "alert_email" {
  type = string
}

# Step 1: Create encrypted SNS topic with DLQ
resource "aws_sns_topic" "waf_alerts" {
  name              = "waf-comprehensive-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.waf_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_sqs_queue" "dlq" {
  name                      = "waf-alerts-dlq"
  message_retention_seconds = 1209600  # 14 days
  kms_master_key_id        = "alias/aws/sqs"
}

# Step 2: Create comprehensive WAF WebACL with multiple rule groups
resource "aws_wafv2_web_acl" "comprehensive" {
  name  = var.web_acl_name
  scope = "REGIONAL"

  default_action {
    allow {}
  }

  # SQLi Protection (200 WCU)
  rule {
    name     = "AWSManagedRulesSQLiRuleSet"
    priority = 1

    statement {
      managed_rule_group_statement {
        vendor_name = "AWS"
        name        = "AWSManagedRulesSQLiRuleSet"
      }
    }

    override_action {
      none {}
    }

    visibility_config {
      sampled_requests_enabled   = true
      cloudwatch_metrics_enabled = true
      metric_name                = "SQLiRuleSetMetric"
    }
  }

  # Known Bad Inputs (200 WCU)
  rule {
    name     = "AWSManagedRulesKnownBadInputsRuleSet"
    priority = 2

    statement {
      managed_rule_group_statement {
        vendor_name = "AWS"
        name        = "AWSManagedRulesKnownBadInputsRuleSet"
      }
    }

    override_action {
      none {}
    }

    visibility_config {
      sampled_requests_enabled   = true
      cloudwatch_metrics_enabled = true
      metric_name                = "BadInputsMetric"
    }
  }

  # Linux Operating System Protection (200 WCU)
  rule {
    name     = "AWSManagedRulesLinuxRuleSet"
    priority = 3

    statement {
      managed_rule_group_statement {
        vendor_name = "AWS"
        name        = "AWSManagedRulesLinuxRuleSet"
      }
    }

    override_action {
      none {}
    }

    visibility_config {
      sampled_requests_enabled   = true
      cloudwatch_metrics_enabled = true
      metric_name                = "LinuxRuleSetMetric"
    }
  }

  # Unix Operating System Protection (100 WCU)
  rule {
    name     = "AWSManagedRulesUnixRuleSet"
    priority = 4

    statement {
      managed_rule_group_statement {
        vendor_name = "AWS"
        name        = "AWSManagedRulesUnixRuleSet"
      }
    }

    override_action {
      none {}
    }

    visibility_config {
      sampled_requests_enabled   = true
      cloudwatch_metrics_enabled = true
      metric_name                = "UnixRuleSetMetric"
    }
  }

  visibility_config {
    sampled_requests_enabled   = true
    cloudwatch_metrics_enabled = true
    metric_name                = var.web_acl_name
  }
}

# Step 3: CloudWatch Alarms for each rule group
resource "aws_cloudwatch_metric_alarm" "sqli_attack" {
  alarm_name          = "WAF-SQLi-Attack-Detected"
  alarm_description   = "SQL injection attacks detected by WAF"
  metric_name         = "BlockedRequests"
  namespace           = "AWS/WAFV2"
  statistic           = "Sum"
  period              = 300
  threshold           = 10
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  dimensions = {
    WebACL = var.web_acl_name
    Rule   = "AWSManagedRulesSQLiRuleSet"
    Region = data.aws_region.current.name
  }

  alarm_actions = [aws_sns_topic.waf_alerts.arn]
}

resource "aws_cloudwatch_metric_alarm" "linux_exploit" {
  alarm_name          = "WAF-Linux-Exploit-Detected"
  alarm_description   = "Linux OS exploitation attempts detected"
  metric_name         = "BlockedRequests"
  namespace           = "AWS/WAFV2"
  statistic           = "Sum"
  period              = 300
  threshold           = 5
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  dimensions = {
    WebACL = var.web_acl_name
    Rule   = "AWSManagedRulesLinuxRuleSet"
    Region = data.aws_region.current.name
  }

  alarm_actions = [aws_sns_topic.waf_alerts.arn]
}

resource "aws_cloudwatch_metric_alarm" "bad_inputs" {
  alarm_name          = "WAF-BadInputs-Detected"
  alarm_description   = "Known bad input patterns detected"
  metric_name         = "BlockedRequests"
  namespace           = "AWS/WAFV2"
  statistic           = "Sum"
  period              = 300
  threshold           = 20
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  dimensions = {
    WebACL = var.web_acl_name
    Rule   = "AWSManagedRulesKnownBadInputsRuleSet"
    Region = data.aws_region.current.name
  }

  alarm_actions = [aws_sns_topic.waf_alerts.arn]
}

data "aws_region" "current" {}

output "web_acl_arn" {
  description = "ARN of the WAF WebACL"
  value       = aws_wafv2_web_acl.comprehensive.arn
}

output "total_wcu" {
  description = "Total WCU consumed"
  value       = "700 WCU (SQLi:200 + BadInputs:200 + Linux:200 + Unix:100)"
}""",
                alert_severity="critical",
                alert_title="WAF Comprehensive Protection - Exploitation Attempts Detected",
                alert_description_template="WAF blocked {count} exploitation attempts across multiple rule groups (SQLi, Linux, Unix, BadInputs).",
                investigation_steps=[
                    "Review WAF logs to identify which rule groups triggered",
                    "Analyse blocked request patterns and payloads",
                    "Identify targeted endpoints and attack vectors",
                    "Check if attacks are distributed or from single source",
                    "Review application logs for bypass attempts",
                    "Correlate with Shield Advanced if DDoS detected",
                    "Verify if any requests succeeded before WAF deployment",
                ],
                containment_actions=[
                    "Block attacking IPs immediately via WAF IP sets",
                    "Enable rate limiting for affected endpoints",
                    "Review and patch vulnerable code paths",
                    "Consider count mode for tuning before full block",
                    "Add custom rules for application-specific patterns",
                    "Enable Shield Advanced if under sustained attack",
                    "Escalate to security team for incident response",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Use count mode initially to baseline; exclude legitimate SQL keywords in app data; tune Linux/Unix rules for CI/CD tools",
            detection_coverage="90% - comprehensive OWASP Top 10 + OS-specific exploitation coverage",
            evasion_considerations="Novel zero-days, advanced obfuscation, second-order injections, application-specific bypasses",
            implementation_effort=EffortLevel.LOW,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$15-30 (WAF rules) + $1 per million requests",
            prerequisites=[
                "ALB, API Gateway, or CloudFront distribution",
                "WCU capacity planning (700 WCU total)",
            ],
        ),
        DetectionStrategy(
            strategy_id="t1190-aws-shield-advanced",
            name="AWS Shield Advanced DDoS Detection",
            description="Enable Shield Advanced for Layer 3/4/7 DDoS protection with automatic mitigation.",
            detection_type=DetectionType.EVENTBRIDGE_RULE,
            aws_service="shield",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: AWS Shield Advanced DDoS detection and alerting

Parameters:
  ResourceARN:
    Type: String
    Description: ARN of ALB/CloudFront to protect
  AlertEmail:
    Type: String

Resources:
  # Step 1: Create encrypted SNS topic with DLQ
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  # Step 2: Create DLQ for failed notifications
  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      MessageRetentionPeriod: 1209600  # 14 days
      KmsMasterKeyId: alias/aws/sqs

  # Step 3: EventBridge rule for Shield Advanced events
  ShieldDDoSRule:
    Type: AWS::Events::Rule
    Properties:
      Name: Shield-Advanced-DDoS-Detection
      EventPattern:
        source:
          - aws.shield
        detail-type:
          - AWS Shield Advanced DDoS Event
      State: ENABLED
      Targets:
        - Id: SNSTarget
          Arn: !Ref AlertTopic
          RetryPolicy:
            MaximumRetryAttempts: 3
            MaximumEventAge: 3600
          DeadLetterConfig:
            Arn: !GetAtt DeadLetterQueue.Arn

  TopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics: [!Ref AlertTopic]
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic
            Condition:
              StringEquals:
                AWS:SourceAccount: !Ref AWS::AccountId
              ArnEquals:
                aws:SourceArn: !GetAtt ShieldDDoSRule.Arn

Outputs:
  ShieldNote:
    Value: Shield Advanced must be enabled manually via console - $3000/month subscription""",
                terraform_template="""# AWS Shield Advanced DDoS detection and alerting

variable "resource_arn" {
  type        = string
  description = "ARN of ALB/CloudFront to protect"
}

variable "alert_email" {
  type = string
}

# Step 1: Create encrypted SNS topic
resource "aws_sns_topic" "shield_alerts" {
  name              = "shield-advanced-ddos-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.shield_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Step 2: Create DLQ for failed notifications
resource "aws_sqs_queue" "dlq" {
  name                      = "shield-alerts-dlq"
  message_retention_seconds = 1209600  # 14 days
  kms_master_key_id        = "alias/aws/sqs"
}

# SQS Queue Policy for EventBridge DLQ (CRITICAL)
# Without this, EventBridge cannot send failed events to the DLQ
data "aws_iam_policy_document" "eventbridge_dlq_policy" {
  statement {
    sid     = "AllowEventBridgeToSendToDLQ"
    effect  = "Allow"
    actions = ["sqs:SendMessage"]

    principals {
      type        = "Service"
      identifiers = ["events.amazonaws.com"]
    }

    resources = [aws_sqs_queue.dlq.arn]

    condition {
      test     = "StringEquals"
      variable = "AWS:SourceAccount"
      values   = [data.aws_caller_identity.current.account_id]
    }

    condition {
      test     = "ArnEquals"
      variable = "aws:SourceArn"
      values   = [aws_cloudwatch_event_rule.shield_ddos.arn]
    }
  }
}

resource "aws_sqs_queue_policy" "event_dlq" {
  queue_url = aws_sqs_queue.dlq.url
  policy    = data.aws_iam_policy_document.eventbridge_dlq_policy.json
}

# Step 3: EventBridge rule for Shield Advanced events
resource "aws_cloudwatch_event_rule" "shield_ddos" {
  name = "Shield-Advanced-DDoS-Detection"

  event_pattern = jsonencode({
    source      = ["aws.shield"]
    detail-type = ["AWS Shield Advanced DDoS Event"]
  })
}

resource "aws_cloudwatch_event_target" "sns" {
  rule = aws_cloudwatch_event_rule.shield_ddos.name
target_id = "SendToSNS"
  arn  = aws_sns_topic.shield_alerts.arn

  retry_policy {
    maximum_retry_attempts = 3
    maximum_event_age_in_seconds      = 3600
  }

  dead_letter_config {
    arn = aws_sqs_queue.dlq.arn
  }
  input_transformer {
    input_paths = {
      account = "$.account"
      region  = "$.region"
      time    = "$.time"
      source  = "$.source"
      detail  = "$.detail"
    }

    input_template = <<-EOT
"Security Alert
Time: <time>
Account: <account>
Region: <region>
Source: <source>
Action: Review event details and investigate"
EOT
  }

}

data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "allow_eventbridge" {
  arn = aws_sns_topic.shield_alerts.arn

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect    = "Allow"
      Principal = { Service = "events.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.shield_alerts.arn
    Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
          ArnEquals = {
            "aws:SourceArn" = aws_cloudwatch_event_rule.shield_ddos.arn
          }
      }
    }]
  })
}

# Note: Shield Advanced protection must be enabled manually
# Subscription cost: $3000/month
# resource "aws_shield_protection" "main" {
#   name         = "shield-protection"
#   resource_arn = var.resource_arn
# }""",
                alert_severity="critical",
                alert_title="DDoS Attack Detected by Shield Advanced",
                alert_description_template="Shield Advanced detected DDoS attack: {attack_vector}. Automatic mitigation in progress.",
                investigation_steps=[
                    "Review Shield Advanced dashboard for attack details",
                    "Check attack vectors (SYN flood, UDP reflection, etc.)",
                    "Monitor application availability metrics",
                    "Review CloudWatch metrics for traffic spikes",
                    "Check if attack is targeting specific endpoints",
                ],
                containment_actions=[
                    "Shield Advanced auto-mitigates - monitor effectiveness",
                    "Engage AWS DDoS Response Team (DRT) if subscribed",
                    "Review WAF rules for application-layer attacks",
                    "Scale infrastructure if needed",
                    "Document incident for post-mortem analysis",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Shield Advanced has built-in ML-based anomaly detection with very low FP rate",
            detection_coverage="95% - comprehensive Layer 3/4/7 DDoS protection",
            evasion_considerations="Application-layer attacks disguised as legitimate traffic",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="2 hours",
            estimated_monthly_cost="$3000 (Shield Advanced subscription) + data transfer fees",
            prerequisites=[
                "Shield Advanced subscription, protected resources (ALB/CloudFront)"
            ],
        ),
        DetectionStrategy(
            strategy_id="t1190-aws-imds-ssrf",
            name="IMDS SSRF Attack Detection",
            description="Detect SSRF attacks targeting EC2 Instance Metadata Service (169.254.169.254).",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query=r"""fields @timestamp, @message
| filter @message like /169\.254\.169\.254/
| parse @message /(?<ip>\d+\.\d+\.\d+\.\d+).*169\.254\.169\.254/
| stats count(*) as imds_requests by ip, bin(5m)
| filter imds_requests > 5
| sort @timestamp desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect SSRF attacks targeting IMDS (169.254.169.254)

Parameters:
  VPCFlowLogGroup:
    Type: String
    Description: VPC Flow Logs log group name
  ApplicationLogGroup:
    Type: String
    Description: Application log group name
  AlertEmail:
    Type: String

Resources:
  # Step 1: Create encrypted SNS topic
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  # Step 2: Metric filter for IMDS access in application logs
  IMDSAccessFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref ApplicationLogGroup
      FilterPattern: '[... , ip = "169.254.169.254", ...]'
      MetricTransformations:
        - MetricName: IMDSAccessAttempts
          MetricNamespace: Security/SSRF
          MetricValue: "1"

  # Step 3: Alert on suspicious IMDS access
  IMDSAccessAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: IMDS-SSRF-Attack-Detected
      MetricName: IMDSAccessAttempts
      Namespace: Security/SSRF
      Statistic: Sum
      Period: 300
      Threshold: 10
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]
      AlarmDescription: Detects potential SSRF attacks targeting EC2 metadata service""",
                terraform_template="""# Detect SSRF attacks targeting IMDS (169.254.169.254)

variable "vpc_flow_log_group" {
  type        = string
  description = "VPC Flow Logs log group name"
}

variable "application_log_group" {
  type        = string
  description = "Application log group name"
}

variable "alert_email" {
  type = string
}

# Step 1: Create encrypted SNS topic
resource "aws_sns_topic" "imds_alerts" {
  name              = "imds-ssrf-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.imds_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Step 2: Metric filter for IMDS access in application logs
resource "aws_cloudwatch_log_metric_filter" "imds_access" {
  name           = "imds-access-attempts"
  log_group_name = var.application_log_group
  pattern        = "[... , ip = \"169.254.169.254\", ...]"

  metric_transformation {
    name      = "IMDSAccessAttempts"
    namespace = "Security/SSRF"
    value     = "1"
  }
}

# Step 3: Alert on suspicious IMDS access
resource "aws_cloudwatch_metric_alarm" "imds_ssrf" {
  alarm_name          = "IMDS-SSRF-Attack-Detected"
  alarm_description   = "Detects potential SSRF attacks targeting EC2 metadata service"
  metric_name         = "IMDSAccessAttempts"
  namespace           = "Security/SSRF"
  statistic           = "Sum"
  period              = 300
  threshold           = 10
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.imds_alerts.arn]
}""",
                alert_severity="critical",
                alert_title="SSRF Attack Targeting IMDS Detected",
                alert_description_template="Detected {count} attempts to access 169.254.169.254 - potential SSRF attack targeting EC2 metadata service.",
                investigation_steps=[
                    "Identify the source application/instance making IMDS requests",
                    "Review application logs for URL parameters containing 169.254.169.254",
                    "Check if IMDSv2 is enforced on EC2 instances",
                    "Review recent deployments for SSRF vulnerabilities",
                    "Verify if IAM credentials were accessed via IMDS",
                    "Check for unusual API calls using potentially stolen credentials",
                ],
                containment_actions=[
                    "Immediately enforce IMDSv2 on affected instances",
                    "Disable IMDSv1 via instance metadata options",
                    "Rotate IAM role credentials for affected instances",
                    "Add WAF rules blocking 169.254.169.254 in URLs",
                    "Patch application SSRF vulnerabilities",
                    "Review and revoke potentially compromised sessions",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Legitimate AWS SDK calls use IMDSv2; this detects suspicious v1 access patterns",
            detection_coverage="80% - catches SSRF attempts in logs",
            evasion_considerations="Obfuscated IP addresses, IMDSv2 bypass (requires custom headers)",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-10 (log ingestion)",
            prerequisites=[
                "Application logging enabled, VPC Flow Logs, IMDSv2 migration plan"
            ],
        ),
        DetectionStrategy(
            strategy_id="t1190-aws-imdsv2-enforcement",
            name="IMDSv2 Enforcement Monitoring",
            description="Monitor EC2 instances to ensure IMDSv2 is enforced and detect IMDSv1 usage attempts.",
            detection_type=DetectionType.EVENTBRIDGE_RULE,
            aws_service="ec2",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Monitor IMDSv2 enforcement and detect IMDSv1 usage

Parameters:
  AlertEmail:
    Type: String

Resources:
  # Step 1: Create encrypted SNS topic with DLQ
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      MessageRetentionPeriod: 1209600  # 14 days
      KmsMasterKeyId: alias/aws/sqs

  # Step 2: EventBridge rule for EC2 launches without IMDSv2
  IMDSv2NotEnforcedRule:
    Type: AWS::Events::Rule
    Properties:
      Name: EC2-IMDSv2-Not-Enforced
      Description: Detect EC2 instances launched without IMDSv2 enforcement
      EventPattern:
        source:
          - aws.ec2
        detail-type:
          - EC2 Instance State-change Notification
        detail:
          state:
            - running
      State: ENABLED
      Targets:
        - Id: LambdaTarget
          Arn: !GetAtt IMDSv2CheckFunction.Arn
          RetryPolicy:
            MaximumRetryAttempts: 3
            MaximumEventAge: 3600
          DeadLetterConfig:
            Arn: !GetAtt DeadLetterQueue.Arn

  # Step 3: Lambda to check IMDSv2 enforcement
  IMDSv2CheckFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: check-imdsv2-enforcement
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      DeadLetterConfig:
        TargetArn: !GetAtt DeadLetterQueue.Arn
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref AlertTopic
      Code:
        ZipFile: |
          import boto3
          import os
          import json

          ec2 = boto3.client('ec2')
          sns = boto3.client('sns')

          def lambda_handler(event, context):
              instance_id = event['detail']['instance-id']

              # Check instance metadata options
              response = ec2.describe_instances(InstanceIds=[instance_id])
              instance = response['Reservations'][0]['Instances'][0]

              metadata_options = instance.get('MetadataOptions', {})
              http_tokens = metadata_options.get('HttpTokens', 'optional')

              if http_tokens != 'required':
                  # IMDSv2 not enforced - send alert
                  message = {
                      'severity': 'HIGH',
                      'instance_id': instance_id,
                      'http_tokens': http_tokens,
                      'message': f'EC2 instance {instance_id} launched without IMDSv2 enforcement',
                      'remediation': 'Run: aws ec2 modify-instance-metadata-options --instance-id {instance_id} --http-tokens required'
                  }

                  sns.publish(
                      TopicArn=os.environ['SNS_TOPIC_ARN'],
                      Subject='IMDSv2 Not Enforced on EC2 Instance',
                      Message=json.dumps(message, indent=2)
                  )

              return {'statusCode': 200}

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: IMDSv2CheckPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                Resource: '*'
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref AlertTopic
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource: !GetAtt DeadLetterQueue.Arn

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref IMDSv2CheckFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt IMDSv2NotEnforcedRule.Arn

  TopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics: [!Ref AlertTopic]
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sns:Publish
            Resource: !Ref AlertTopic

Outputs:
  Remediation:
    Description: Command to enforce IMDSv2
    Value: "aws ec2 modify-instance-metadata-options --instance-id <INSTANCE_ID> --http-tokens required --http-put-response-hop-limit 1""",
                terraform_template="""# Monitor IMDSv2 enforcement and detect IMDSv1 usage

variable "alert_email" {
  type = string
}

# Step 1: Create encrypted SNS topic with DLQ
resource "aws_sns_topic" "imdsv2_alerts" {
  name              = "imdsv2-enforcement-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.imdsv2_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_sqs_queue" "dlq" {
  name                      = "imdsv2-check-dlq"
  message_retention_seconds = 1209600  # 14 days
  kms_master_key_id        = "alias/aws/sqs"
}

# SQS Queue Policy for EventBridge DLQ (CRITICAL)
# Without this, EventBridge cannot send failed events to the DLQ
data "aws_iam_policy_document" "imdsv2_dlq_policy" {
  statement {
    sid     = "AllowEventBridgeToSendToDLQ"
    effect  = "Allow"
    actions = ["sqs:SendMessage"]

    principals {
      type        = "Service"
      identifiers = ["events.amazonaws.com"]
    }

    resources = [aws_sqs_queue.dlq.arn]

    condition {
      test     = "StringEquals"
      variable = "AWS:SourceAccount"
      values   = [data.aws_caller_identity.current.account_id]
    }

    condition {
      test     = "ArnEquals"
      variable = "aws:SourceArn"
      values   = [aws_cloudwatch_event_rule.ec2_running.arn]
    }
  }
}

resource "aws_sqs_queue_policy" "imdsv2_dlq" {
  queue_url = aws_sqs_queue.dlq.url
  policy    = data.aws_iam_policy_document.imdsv2_dlq_policy.json
}

# Step 2: EventBridge rule for EC2 launches
resource "aws_cloudwatch_event_rule" "ec2_running" {
  name        = "EC2-IMDSv2-Not-Enforced"
  description = "Detect EC2 instances launched without IMDSv2 enforcement"

  event_pattern = jsonencode({
    source      = ["aws.ec2"]
    detail-type = ["EC2 Instance State-change Notification"]
    detail = {
      state = ["running"]
    }
  })
}

# Step 3: Lambda to check IMDSv2 enforcement
resource "aws_lambda_function" "imdsv2_check" {
  filename      = "imdsv2_check.zip"  # Package the Python code
  function_name = "check-imdsv2-enforcement"
  role          = aws_iam_role.lambda_exec.arn
  handler       = "index.lambda_handler"
  runtime       = "python3.11"

  dead_letter_config {
    target_arn = aws_sqs_queue.dlq.arn
  }

  environment {
    variables = {
      SNS_TOPIC_ARN = aws_sns_topic.imdsv2_alerts.arn
    }
  }

  source_code_hash = filebase64sha256("imdsv2_check.zip")
}

resource "aws_cloudwatch_event_target" "lambda" {
  rule = aws_cloudwatch_event_rule.ec2_running.name
target_id = "SendToLambda"
  arn  = aws_lambda_function.imdsv2_check.arn

  retry_policy {
    maximum_retry_attempts = 3
    maximum_event_age_in_seconds      = 3600
  }

  dead_letter_config {
    arn = aws_sqs_queue.dlq.arn
  }
  input_transformer {
    input_paths = {
      account = "$.account"
      region  = "$.region"
      time    = "$.time"
      source  = "$.source"
      detail  = "$.detail"
    }

    input_template = <<-EOT
"Security Alert
Time: <time>
Account: <account>
Region: <region>
Source: <source>
Action: Review event details and investigate"
EOT
  }

}

resource "aws_lambda_permission" "allow_eventbridge" {
  statement_id  = "AllowExecutionFromEventBridge"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.imdsv2_check.function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.ec2_running.arn
}

resource "aws_iam_role" "lambda_exec" {
  name = "imdsv2-check-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Principal = {
        Service = "lambda.amazonaws.com"
      }
      Action = "sts:AssumeRole"
    }]
  })
}

resource "aws_iam_role_policy_attachment" "lambda_basic" {
  role       = aws_iam_role.lambda_exec.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

resource "aws_iam_role_policy" "lambda_policy" {
  name = "imdsv2-check-policy"
  role = aws_iam_role.lambda_exec.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "sns:Publish"
        ]
        Resource = aws_sns_topic.imdsv2_alerts.arn
      },
      {
        Effect = "Allow"
        Action = [
          "sqs:SendMessage"
        ]
        Resource = aws_sqs_queue.dlq.arn
      }
    ]
  })
}

output "remediation_command" {
  description = "Command to enforce IMDSv2"
  value       = "aws ec2 modify-instance-metadata-options --instance-id <INSTANCE_ID> --http-tokens required --http-put-response-hop-limit 1"
}""",
                alert_severity="high",
                alert_title="EC2 Instance Launched Without IMDSv2 Enforcement",
                alert_description_template="EC2 instance {instance_id} is running without IMDSv2 enforcement, vulnerable to SSRF attacks.",
                investigation_steps=[
                    "Identify the instance launch source (Auto Scaling, manual, etc.)",
                    "Check if instance was launched from compliant AMI",
                    "Review launch templates and Auto Scaling configurations",
                    "Verify if instance role has sensitive permissions",
                    "Check VPC Flow Logs for IMDS access attempts",
                    "Review CloudTrail for recent instance launches",
                ],
                containment_actions=[
                    "Enforce IMDSv2: aws ec2 modify-instance-metadata-options --instance-id <ID> --http-tokens required",
                    "Update launch templates to require IMDSv2",
                    "Update Auto Scaling configurations",
                    "Create SCP to prevent IMDSv1 in future launches",
                    "Audit all running instances for IMDSv2 enforcement",
                    "Document IMDSv2 requirement in security standards",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Exclude instances with legitimate IMDSv1 requirements during migration period",
            detection_coverage="100% - detects all new EC2 launches without IMDSv2",
            evasion_considerations="None - enforces IMDSv2 at instance level",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="2-3 hours",
            estimated_monthly_cost="$5-15 (Lambda invocations + CloudWatch)",
            prerequisites=[
                "EventBridge enabled",
                "Lambda execution role",
                "IMDSv2 migration plan",
            ],
        ),
        DetectionStrategy(
            strategy_id="t1190-aws-api-gateway-errors",
            name="API Gateway Exploitation Detection",
            description="Detect exploitation attempts via API Gateway 4xx/5xx error spikes.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, status, ip, resource, method
| filter status >= 400
| stats count(*) as errors,
        sum(case when status >= 500 then 1 else 0 end) as server_errors,
        sum(case when status >= 400 and status < 500 then 1 else 0 end) as client_errors
  by ip, resource, bin(5m)
| filter errors > 50 or server_errors > 10
| sort errors desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect API exploitation via error rate spikes

Parameters:
  APIGatewayName:
    Type: String
  AlertEmail:
    Type: String

Resources:
  # Step 1: Create encrypted SNS topic
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  # Step 2: Monitor 4xx error rate (client errors)
  Client4xxAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${APIGatewayName}-4xx-spike'
      MetricName: 4XXError
      Namespace: AWS/ApiGateway
      Dimensions:
        - Name: ApiName
          Value: !Ref APIGatewayName
      Statistic: Sum
      Period: 300
      Threshold: 100
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]
      AlarmDescription: Detects potential exploitation attempts via client errors

  # Step 3: Monitor 5xx error rate (server errors)
  Server5xxAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${APIGatewayName}-5xx-spike'
      MetricName: 5XXError
      Namespace: AWS/ApiGateway
      Dimensions:
        - Name: ApiName
          Value: !Ref APIGatewayName
      Statistic: Sum
      Period: 300
      Threshold: 20
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]
      AlarmDescription: Detects server errors indicating exploitation attempts""",
                terraform_template="""# Detect API exploitation via error rate spikes

variable "api_gateway_name" {
  type = string
}

variable "alert_email" {
  type = string
}

# Step 1: Create encrypted SNS topic
resource "aws_sns_topic" "api_alerts" {
  name              = "api-gateway-exploit-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.api_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Step 2: Monitor 4xx error rate (client errors)
resource "aws_cloudwatch_metric_alarm" "api_4xx_spike" {
  alarm_name          = "${var.api_gateway_name}-4xx-spike"
  alarm_description   = "Detects potential exploitation attempts via client errors"
  metric_name         = "4XXError"
  namespace           = "AWS/ApiGateway"
  statistic           = "Sum"
  period              = 300
  threshold           = 100
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1

  dimensions = {
    ApiName = var.api_gateway_name
  }

  treat_missing_data  = "notBreaching"


  alarm_actions       = [aws_sns_topic.api_alerts.arn]
}

# Step 3: Monitor 5xx error rate (server errors)
resource "aws_cloudwatch_metric_alarm" "api_5xx_spike" {
  alarm_name          = "${var.api_gateway_name}-5xx-spike"
  alarm_description   = "Detects server errors indicating exploitation attempts"
  metric_name         = "5XXError"
  namespace           = "AWS/ApiGateway"
  statistic           = "Sum"
  period              = 300
  threshold           = 20
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1

  dimensions = {
    ApiName = var.api_gateway_name
  }

  treat_missing_data  = "notBreaching"


  alarm_actions       = [aws_sns_topic.api_alerts.arn]
}""",
                alert_severity="high",
                alert_title="API Gateway Exploitation Attempt Detected",
                alert_description_template="API Gateway {api_name} experienced {error_count} errors in 5 minutes - potential exploitation.",
                investigation_steps=[
                    "Review API Gateway access logs for error patterns",
                    "Identify endpoints with highest error rates",
                    "Check for parameter tampering or injection attempts",
                    "Review authoriser logs for authentication bypasses",
                    "Correlate with WAF logs if WAF is enabled",
                    "Check for successful requests from same IPs",
                ],
                containment_actions=[
                    "Enable request throttling on affected endpoints",
                    "Add WAF rules to API Gateway if not present",
                    "Implement IP-based rate limiting",
                    "Review and patch vulnerable Lambda functions",
                    "Enable API Gateway logging if not enabled",
                    "Consider enabling AWS Shield for DDoS protection",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Baseline normal error rates; exclude health checks and monitoring",
            detection_coverage="70% - catches exploitation attempts causing errors",
            evasion_considerations="Successful exploits may not trigger errors; low-and-slow attacks",
            implementation_effort=EffortLevel.LOW,
            implementation_time="45 minutes",
            estimated_monthly_cost="$5-10 (CloudWatch metrics)",
            prerequisites=["API Gateway with CloudWatch metrics enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1190-aws-alb",
            name="ALB Suspicious Request Detection",
            description="Detect exploitation attempts via ALB access logs.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, client_ip, request_url, elb_status_code
| filter request_url like /\\.\\.|etc|cmd=|exec|script|UNION.*SELECT/
| stats count(*) as suspicious by client_ip, bin(1h)
| filter suspicious > 5
| sort suspicious desc""",
                terraform_template="""# Detect exploitation via ALB logs

variable "alb_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "alb-exploit-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "suspicious_requests" {
  name           = "suspicious-requests"
  log_group_name = var.alb_log_group
  pattern        = "[\"..\", \"/etc/\", \"cmd=\", \"<script\"]"

  metric_transformation {
    name      = "SuspiciousRequests"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "exploit_attempt" {
  alarm_name          = "ExploitAttempt"
  metric_name         = "SuspiciousRequests"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 20
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}""",
                alert_severity="high",
                alert_title="Exploitation Attempt Detected",
                alert_description_template="Suspicious requests from {client_ip}.",
                investigation_steps=[
                    "Review request patterns",
                    "Check application response codes",
                    "Review application logs",
                    "Check for successful exploitation",
                ],
                containment_actions=[
                    "Block attacking IP",
                    "Review application security",
                    "Enable WAF if not present",
                    "Patch vulnerabilities",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Tune patterns for your application",
            detection_coverage="60% - pattern-based detection",
            evasion_considerations="Encoded payloads may evade",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-15",
            prerequisites=["ALB access logging enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1190-gcp-armor-preconfigured",
            name="GCP Cloud Armor Preconfigured WAF Rules",
            description="Deploy Cloud Armor with OWASP CRS 3.3 preconfigured WAF rules.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_armor",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''resource.type="http_load_balancer"
jsonPayload.enforcedSecurityPolicy.outcome="DENY"
jsonPayload.enforcedSecurityPolicy.preconfiguredExprIds=~".*"''',
                gcp_terraform_template="""# GCP: Cloud Armor with OWASP CRS 3.3 preconfigured WAF rules

variable "project_id" {
  type = string
}

variable "alert_email" {
  type = string
}

variable "backend_service_name" {
  type = string
}

# Step 1: Create Cloud Armor security policy with OWASP rules
resource "google_compute_security_policy" "owasp_protection" {
  name = "owasp-waf-protection"

  # SQLi protection (sensitivity level 1 = high confidence)
  rule {
    action   = "deny(403)"
    priority = "1000"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('sqli-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "SQL injection protection"
  }

  # XSS protection
  rule {
    action   = "deny(403)"
    priority = "1100"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('xss-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Cross-site scripting protection"
  }

  # LFI (Local File Inclusion) protection
  rule {
    action   = "deny(403)"
    priority = "1200"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('lfi-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Local file inclusion protection"
  }

  # RFI (Remote File Inclusion) protection
  rule {
    action   = "deny(403)"
    priority = "1300"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('rfi-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Remote file inclusion protection"
  }

  # RCE (Remote Code Execution) protection
  rule {
    action   = "deny(403)"
    priority = "1400"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('rce-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Remote code execution protection"
  }

  # Method enforcement
  rule {
    action   = "deny(403)"
    priority = "1500"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('methodenforcement-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Method enforcement protection"
  }

  # Scanner detection
  rule {
    action   = "deny(403)"
    priority = "1600"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('scannerdetection-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Scanner detection"
  }

  # Protocol attack protection
  rule {
    action   = "deny(403)"
    priority = "1700"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('protocolattack-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Protocol attack protection"
  }

  # PHP injection protection
  rule {
    action   = "deny(403)"
    priority = "1800"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('php-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "PHP injection protection"
  }

  # Session fixation protection
  rule {
    action   = "deny(403)"
    priority = "1900"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('sessionfixation-v33-stable', {'sensitivity': 1})"
      }
    }
    description = "Session fixation protection"
  }

  # CVE-2021-44228 (Log4j) protection
  rule {
    action   = "deny(403)"
    priority = "2000"
    match {
      expr {
        expression = "evaluatePreconfiguredWaf('cve-canary', {'sensitivity': 0})"
      }
    }
    description = "CVE protection (Log4j, etc.)"
  }

  # Default rule - allow traffic
  rule {
    action   = "allow"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Default allow rule"
  }
}

# Step 2: Attach policy to backend service
resource "google_compute_backend_service_security_policy_attachment" "policy_attachment" {
  backend_service = var.backend_service_name
  security_policy = google_compute_security_policy.owasp_protection.id
}

# Step 3: Create notification channel
resource "google_monitoring_notification_channel" "email_s1" {
  project      = var.project_id
  display_name = "Security Alerts Email"
  type         = "email"
  labels = {
    email_address = var.alert_email
  }
}

# Step 4: Create log-based metric for Cloud Armor blocks
resource "google_logging_metric" "armor_blocks" {
  project = var.project_id
  name   = "cloud-armor-blocks"
  filter = <<-EOT
    resource.type="http_load_balancer"
    jsonPayload.enforcedSecurityPolicy.outcome="DENY"
    jsonPayload.enforcedSecurityPolicy.preconfiguredExprIds=~".*"
  EOT

  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
    labels {
      key         = "rule_id"
      value_type  = "STRING"
      description = "Triggered WAF rule ID"
    }
  }

  label_extractors = {
    "rule_id" = "EXTRACT(jsonPayload.enforcedSecurityPolicy.preconfiguredExprIds)"
  }
}

# Step 5: Alert on blocked exploitation attempts
resource "google_monitoring_alert_policy" "armor_attacks" {
  project      = var.project_id
  display_name = "Cloud Armor OWASP Rule Violations"
  combiner     = "OR"

  conditions {
    display_name = "High block rate from WAF rules"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.armor_blocks.name}\" resource.type=\"http_load_balancer\""
      duration        = "300s"
      comparison      = "COMPARISON_GT"
      threshold_value = 50
      aggregations {
        alignment_period   = "300s"
        per_series_aligner = "ALIGN_RATE"
      }
    }
  }

  notification_channels = [google_monitoring_notification_channel.email_s1.id]

  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }

  documentation {
    content = "Cloud Armor blocked exploitation attempts matching OWASP CRS rules. Review Cloud Logging for attack patterns."
  }
}""",
                alert_severity="high",
                alert_title="GCP: Cloud Armor OWASP Rule Violations",
                alert_description_template="Cloud Armor blocked {count} exploitation attempts matching OWASP rules.",
                investigation_steps=[
                    "Review Cloud Logging for blocked request details",
                    "Identify triggered preconfigured WAF rules",
                    "Check source IPs and geographic distribution",
                    "Review application logs for bypass attempts",
                    "Verify sensitivity levels are appropriate",
                    "Check for false positives in legitimate traffic",
                ],
                containment_actions=[
                    "Add IP-based rate limiting for repeat offenders",
                    "Increase sensitivity levels if attacks persist",
                    "Review application code for vulnerabilities",
                    "Enable request body inspection (up to 64KB)",
                    "Add custom rules for application-specific threats",
                    "Consider geo-blocking if attacks are regional",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Start with sensitivity level 1, tune exclusions for legitimate app patterns",
            detection_coverage="85% - OWASP CRS 3.3 comprehensive coverage",
            evasion_considerations="Novel zero-days, advanced obfuscation, application-specific bypasses",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="2-3 hours",
            estimated_monthly_cost="15-40 (policy rules) + 0.75 per million requests",
            prerequisites=["GCP Load Balancer, backend service configured"],
        ),
        # Azure Strategy: Exploit Public-Facing Application
        DetectionStrategy(
            strategy_id="t1190-azure",
            name="Azure Exploit Public-Facing Application Detection",
            description=(
                "Defender for App Service and WAF detect exploitation attempts. "
                "Provides native Azure detection using Log Analytics and Defender for Cloud."
            ),
            detection_type=DetectionType.DEFENDER_ALERT,
            aws_service="n/a",
            azure_service="defender",
            cloud_provider=CloudProvider.AZURE,
            implementation=DetectionImplementation(
                azure_kql_query="""// Azure Log Analytics KQL Query: Exploit Public-Facing Application
// MITRE ATT&CK: T1190
// Detects exploitation attempts against Azure web applications via WAF and App Service
let lookback = 24h;
// Azure WAF blocked requests (Application Gateway)
let wafBlocked = AzureDiagnostics
| where TimeGenerated > ago(lookback)
| where ResourceType == "APPLICATIONGATEWAYS"
| where Category == "ApplicationGatewayFirewallLog"
| where action_s == "Blocked" or action_s == "Matched"
| extend
    AttackType = ruleSetType_s,
    RuleId = ruleId_s,
    Message = Message
| project TimeGenerated, clientIp_s, hostname_s, requestUri_s,
    AttackType, RuleId, Message, action_s
| extend TechniqueDetail = "WAF blocked attack";
// Azure Front Door WAF events
let frontDoorWaf = AzureDiagnostics
| where TimeGenerated > ago(lookback)
| where ResourceType == "FRONTDOORS"
| where Category == "FrontdoorWebApplicationFirewallLog"
| where action_s in ("Block", "Log")
| project TimeGenerated, clientIP_s, host_s, requestUri_s,
    ruleName_s, action_s, policyMode_s
| extend TechniqueDetail = "Front Door WAF event";
// App Service authentication failures (brute force or credential stuffing)
let appServiceAuth = AzureDiagnostics
| where TimeGenerated > ago(lookback)
| where ResourceType == "SITES"
| where Category == "AppServiceAuthenticationLogs"
| where ResultDescription has_any ("Failed", "Unauthorized", "Invalid")
| summarize FailureCount = count() by bin(TimeGenerated, 5m), ClientIP = tostring(split(CallerIpAddress, ":")[0])
| where FailureCount > 10
| extend TechniqueDetail = "Multiple auth failures";
// Defender for Cloud web attack alerts
let defenderAlerts = SecurityAlert
| where TimeGenerated > ago(lookback)
| where ProductName in ("Azure Security Center", "Microsoft Defender for Cloud", "Microsoft Defender for App Service")
| where AlertName has_any (
    "SQL injection", "XSS", "Command injection",
    "Path traversal", "Web shell", "Suspicious request",
    "Potential vulnerability scanner", "Web application attack"
)
| project TimeGenerated, AlertName, AlertSeverity, Description,
    CompromisedEntity, RemediationSteps
| extend TechniqueDetail = "Defender web attack alert";
// Application Gateway access anomalies
let accessAnomalies = AzureDiagnostics
| where TimeGenerated > ago(lookback)
| where ResourceType == "APPLICATIONGATEWAYS"
| where Category == "ApplicationGatewayAccessLog"
| where httpStatus_d >= 400
| summarize
    ErrorCount = count(),
    UniqueUris = dcount(requestUri_s),
    StatusCodes = make_set(httpStatus_d)
    by bin(TimeGenerated, 5m), clientIP_s, host_s
| where ErrorCount > 50 or UniqueUris > 20
| extend TechniqueDetail = "High error rate from IP"
| project TimeGenerated, clientIP_s, host_s, ErrorCount, UniqueUris, StatusCodes, TechniqueDetail""",
                defender_alert_types=[
                    "Web application attack detected",
                    "SQL injection attempt",
                    "Path traversal attack",
                    "Command injection attempt",
                    "Web shell detected",
                    "Potential vulnerability scanner",
                ],
                azure_terraform_template="""# Microsoft Defender for Cloud Detection
# Exploit Public-Facing Application (T1190)
# Defender for App Service and WAF detect exploitation attempts

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = ">= 3.0"
    }
  }
}

variable "resource_group_name" {
  type        = string
  description = "Resource group name"
}

variable "log_analytics_workspace_id" {
  type        = string
  description = "Log Analytics workspace for Defender"
}

variable "alert_email" {
  type        = string
  description = "Email for security alerts"
}

variable "location" {
  type        = string
  description = "Azure region for resources"
  default     = "uksouth"
}

# Enable Defender for Cloud plans
resource "azurerm_security_center_subscription_pricing" "defender_servers" {
  tier          = "Standard"
  resource_type = "VirtualMachines"
}

resource "azurerm_security_center_subscription_pricing" "defender_storage" {
  tier          = "Standard"
  resource_type = "StorageAccounts"
}

resource "azurerm_security_center_subscription_pricing" "defender_keyvault" {
  tier          = "Standard"
  resource_type = "KeyVaults"
}

resource "azurerm_security_center_subscription_pricing" "defender_arm" {
  tier          = "Standard"
  resource_type = "Arm"
}

# Action Group for Defender alerts
resource "azurerm_monitor_action_group" "defender_alerts" {
  name                = "defender-t1190-alerts"
  resource_group_name = var.resource_group_name
  short_name          = "DefAlerts"

  email_receiver {
    name          = "security-team"
    email_address = var.alert_email
  }
}

# Log Analytics query for Defender alerts
resource "azurerm_monitor_scheduled_query_rules_alert_v2" "defender_detection" {
  name                = "defender-t1190"
  resource_group_name = var.resource_group_name
  location            = var.location

  evaluation_frequency = "PT5M"
  window_duration      = "PT1H"
  scopes               = [var.log_analytics_workspace_id]
  severity             = 1

  criteria {
    query = <<-QUERY
SecurityAlert
| where TimeGenerated > ago(1h)
| where ProductName == "Azure Security Center" or ProductName == "Microsoft Defender for Cloud"
| where AlertName has_any (
                    "Web application attack detected",
                    "SQL injection attempt",
                )
| project
    TimeGenerated,
    AlertName,
    AlertSeverity,
    Description,
    RemediationSteps,
    ExtendedProperties,
    Entities
    QUERY

    time_aggregation_method = "Count"
    threshold               = 0
    operator                = "GreaterThan"

    failing_periods {
      minimum_failing_periods_to_trigger_alert = 1
      number_of_evaluation_periods             = 1
    }
  }

  action {
    action_groups = [azurerm_monitor_action_group.defender_alerts.id]
  }

  description = "Defender for App Service and WAF detect exploitation attempts"
  display_name = "Defender: Exploit Public-Facing Application"
  enabled      = true

  tags = {
    "mitre-technique" = "T1190"
    "detection-type"  = "security"
  }
}

output "alert_rule_id" {
  value = azurerm_monitor_scheduled_query_rules_alert_v2.defender_detection.id
}""",
                alert_severity="high",
                alert_title="Azure: Exploit Public-Facing Application Detected",
                alert_description_template=(
                    "Exploit Public-Facing Application activity detected. "
                    "Caller: {Caller}. Resource: {Resource}."
                ),
                investigation_steps=[
                    "Review Azure Activity Log for full operation details",
                    "Check caller identity and verify if authorised",
                    "Review affected resources and assess impact",
                    "Check for related activities in the same time window",
                    "Verify against change management records",
                ],
                containment_actions=[
                    "Disable compromised user/service principal if unauthorised",
                    "Revoke active sessions using Entra ID",
                    "Review and restrict Azure RBAC permissions",
                    "Enable additional Defender for Cloud protections",
                    "Implement Azure Policy to prevent recurrence",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning=(
                "Allowlist known automation accounts and CI/CD service principals. "
                "Use Azure Policy to define expected behaviour baselines."
            ),
            detection_coverage="70% - Azure-native detection for cloud operations",
            evasion_considerations=(
                "Attackers may use legitimate credentials from expected locations. "
                "Combine with Defender for Cloud for ML-based anomaly detection."
            ),
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-50 (Log Analytics + Defender)",
            prerequisites=[
                "Azure subscription with Log Analytics workspace",
                "Defender for Cloud enabled (recommended)",
                "Appropriate Azure RBAC permissions for deployment",
            ],
        ),
    ],
    recommended_order=[
        "t1190-aws-waf-managed-common",
        "t1190-aws-waf-comprehensive",
        "t1190-aws-imdsv2-enforcement",
        "t1190-aws-imds-ssrf",
        "t1190-aws-api-gateway-errors",
        "t1190-aws-shield-advanced",
        "t1190-gcp-armor-preconfigured",
        "t1190-aws-alb",
    ],
    total_effort_hours=12.5,
    coverage_improvement="+40% improvement for Initial Access tactic",
)
