"""
T1595.002 - Active Scanning: Vulnerability Scanning

Adversaries conduct vulnerability scans to identify exploitable weaknesses in
target systems by examining software versions, configurations, and services.
Used by APT28, APT41, Ember Bear, Magic Hound, Sandworm Team.
"""

from .template_loader import (
    RemediationTemplate,
    ThreatContext,
    DetectionStrategy,
    DetectionImplementation,
    DetectionType,
    EffortLevel,
    FalsePositiveRate,
    CloudProvider,
)

TEMPLATE = RemediationTemplate(
    technique_id="T1595.002",
    technique_name="Active Scanning: Vulnerability Scanning",
    tactic_ids=["TA0043"],
    mitre_url="https://attack.mitre.org/techniques/T1595/002/",
    threat_context=ThreatContext(
        description=(
            "Adversaries conduct vulnerability scans on target systems to identify "
            "exploitable weaknesses. These scans examine software versions, configurations, "
            "running services, server banners, and network artifacts to discover commonly "
            "known vulnerabilities that could enable initial access or further reconnaissance."
        ),
        attacker_goal="Identify exploitable vulnerabilities in target infrastructure for initial access",
        why_technique=[
            "Identifies exploitable CVEs remotely",
            "Automated scanning tools widely available",
            "Reveals software versions and patch status",
            "Maps attack surface systematically",
            "Pre-compromise reconnaissance technique",
        ],
        known_threat_actors=[],
        recent_campaigns=[],  # Populated dynamically from MITRE sync data
        prevalence="common",
        trend="increasing",
        severity_score=7,
        severity_reasoning=(
            "Pre-compromise reconnaissance technique that identifies attack vectors. "
            "Occurs outside enterprise defences but directly enables exploitation attempts."
        ),
        business_impact=[
            "Identifies exploitable vulnerabilities",
            "Precedes targeted attacks",
            "Reveals security posture weaknesses",
            "Increases likelihood of breach",
        ],
        typical_attack_phase="reconnaissance",
        often_precedes=["T1190", "T1210", "T1068"],
        often_follows=["T1595.001", "T1590"],
    ),
    detection_strategies=[
        DetectionStrategy(
            strategy_id="t1595-002-aws-waf",
            name="AWS WAF Vulnerability Scan Detection",
            description="Detect vulnerability scanning activity via AWS WAF logs.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, httpRequest.clientIp, httpRequest.uri, httpRequest.headers
| filter httpRequest.headers like /(?i)(Acunetix|Nikto|Nessus|OpenVAS|sqlmap|w3af|Nmap|Burp)/
| stats count(*) as scans by httpRequest.clientIp, bin(5m)
| filter scans > 20
| sort scans desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect vulnerability scanning via WAF logs

Parameters:
  WAFLogGroup:
    Type: String
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  VulnScanFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref WAFLogGroup
      FilterPattern: '[... userAgent="*Acunetix*" || userAgent="*Nikto*" || userAgent="*Nessus*" || userAgent="*sqlmap*"]'
      MetricTransformations:
        - MetricName: VulnerabilityScans
          MetricNamespace: Security
          MetricValue: "1"

  VulnScanAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: VulnerabilityScanDetected
      MetricName: VulnerabilityScans
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 20
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]""",
                terraform_template="""# Detect vulnerability scanning via WAF logs

variable "waf_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "vulnerability-scan-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "vuln_scans" {
  name           = "vulnerability-scans"
  log_group_name = var.waf_log_group
  pattern        = "[... userAgent=\"*Acunetix*\" || userAgent=\"*Nikto*\" || userAgent=\"*Nessus*\" || userAgent=\"*sqlmap*\"]"

  metric_transformation {
    name      = "VulnerabilityScans"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "vuln_scan_detected" {
  alarm_name          = "VulnerabilityScanDetected"
  metric_name         = "VulnerabilityScans"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 20
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}""",
                alert_severity="medium",
                alert_title="Vulnerability Scanning Detected",
                alert_description_template="Vulnerability scanning tools detected from {clientIp}.",
                investigation_steps=[
                    "Identify source IP and geolocation",
                    "Review scanning patterns and targets",
                    "Check for successful exploits following scans",
                    "Correlate with other reconnaissance activity",
                ],
                containment_actions=[
                    "Block scanning IP at WAF/security group",
                    "Review exposed services and patch status",
                    "Enable rate limiting on public endpoints",
                    "Verify no successful exploitation occurred",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Scanner user-agents are distinctive; authorised scans should be allowlisted",
            detection_coverage="65% - catches tool-based scans with identifiable signatures",
            evasion_considerations="Custom scanners with spoofed user-agents may evade",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-25",
            prerequisites=["AWS WAF with logging enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-aws-vpc",
            name="VPC Flow Logs Port Scan Detection",
            description="Detect systematic port scanning via VPC Flow Logs.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, srcaddr, dstaddr, dstport, protocol, action
| filter action = "REJECT"
| stats count_distinct(dstport) as ports by srcaddr, bin(5m)
| filter ports > 50
| sort ports desc""",
                terraform_template="""# Detect port scanning via VPC Flow Logs

variable "vpc_flow_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "port-scan-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "port_scans" {
  name           = "port-scans"
  log_group_name = var.vpc_flow_log_group
  pattern        = "[version, account, eni, source, destination, srcport, destport, protocol, packets, bytes, windowstart, windowend, action=REJECT, flowlogstatus]"

  metric_transformation {
    name      = "PortScans"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "port_scan_detected" {
  alarm_name          = "PortScanDetected"
  metric_name         = "PortScans"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 100
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}""",
                alert_severity="medium",
                alert_title="Port Scanning Activity Detected",
                alert_description_template="Multiple port connection attempts from {srcaddr}.",
                investigation_steps=[
                    "Identify scanning source and target systems",
                    "Review port ranges being scanned",
                    "Check for subsequent exploitation attempts",
                    "Correlate with vulnerability scan signatures",
                ],
                containment_actions=[
                    "Block source IP at network ACL",
                    "Review security group configurations",
                    "Minimise exposed services",
                    "Enable GuardDuty if not present",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Adjust threshold based on legitimate scanning; allowlist authorised security scanners",
            detection_coverage="60% - detects systematic port enumeration",
            evasion_considerations="Slow scans and targeted scanning may evade thresholds",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-15",
            prerequisites=["VPC Flow Logs enabled and published to CloudWatch"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-aws-guardduty",
            name="AWS GuardDuty Port Scan Detection",
            description="Leverage GuardDuty's built-in port scanning detection.",
            detection_type=DetectionType.CONFIG_RULE,
            aws_service="guardduty",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""# GuardDuty Finding Types for Port Scanning:
# - Recon:EC2/PortProbeUnprotectedPort
# - Recon:EC2/PortProbeEMRUnprotectedPort
# - Recon:EC2/Portscan""",
                terraform_template="""# Configure GuardDuty alerts for port scanning

variable "alert_email" { type = string }

resource "aws_guardduty_detector" "main" {
  enable = true
  finding_publishing_frequency = "FIFTEEN_MINUTES"
}

resource "aws_sns_topic" "guardduty_alerts" {
  name = "guardduty-port-scan-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.guardduty_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Dead Letter Queue for EventBridge targets
resource "aws_sqs_queue" "events_dlq" {
  name                      = "guardduty-port-scan-dlq"
  message_retention_seconds = 1209600
}

resource "aws_sqs_queue_policy" "events_dlq" {
  queue_url = aws_sqs_queue.events_dlq.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Principal = {
        Service = "events.amazonaws.com"
      }
      Action   = "sqs:SendMessage"
      Resource = aws_sqs_queue.events_dlq.arn
    }]
  })
}

resource "aws_cloudwatch_event_rule" "port_scan" {
  name        = "guardduty-port-scan"
  description = "Capture GuardDuty port scanning findings"

  event_pattern = jsonencode({
    source      = ["aws.guardduty"]
    detail-type = ["GuardDuty Finding"]
    detail = {
      type = [
        "Recon:EC2/PortProbeUnprotectedPort",
        "Recon:EC2/PortProbeEMRUnprotectedPort",
        "Recon:EC2/Portscan"
      ]
    }
  })
}

resource "aws_cloudwatch_event_target" "sns" {
  rule      = aws_cloudwatch_event_rule.port_scan.name
  target_id = "SendToSNS"
  arn       = aws_sns_topic.guardduty_alerts.arn

  retry_policy {
    maximum_event_age_in_seconds = 3600
    maximum_retry_attempts       = 8
  }

  dead_letter_config {
    arn = aws_sqs_queue.events_dlq.arn
  }
  input_transformer {
    input_paths = {
      account    = "$.account"
      region     = "$.region"
      time       = "$.time"
      type       = "$.detail.type"
      severity   = "$.detail.severity"
      title      = "$.detail.title"
      description = "$.detail.description"
    }

    input_template = <<-EOT
"GuardDuty Finding Alert
Time: <time>
Account: <account>
Region: <region>
Finding: <type>
Severity: <severity>
Title: <title>
Description: <description>
Action: Review finding in GuardDuty console and investigate"
EOT
  }

}

# Allow EventBridge to publish to SNS
data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "allow_eventbridge" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect    = "Allow"
      Principal = { Service = "events.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
    Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
        ArnEquals = {
          "aws:SourceArn" = aws_cloudwatch_event_rule.port_scan.arn
        }
      }
    }]
  })
}""",
                alert_severity="medium",
                alert_title="GuardDuty: Port Scanning Detected",
                alert_description_template="GuardDuty detected port scanning activity against your infrastructure.",
                investigation_steps=[
                    "Review GuardDuty finding details and severity",
                    "Identify targeted instances and services",
                    "Check for successful connections post-scan",
                    "Review network configuration",
                ],
                containment_actions=[
                    "Block malicious IPs via security groups",
                    "Review and harden exposed services",
                    "Implement network segmentation",
                    "Enable additional monitoring",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="GuardDuty findings are pre-tuned; suppress known scanners",
            detection_coverage="80% - comprehensive managed detection",
            evasion_considerations="Very slow or distributed scans may evade",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30 minutes",
            estimated_monthly_cost="$30-100 (GuardDuty service)",
            prerequisites=["AWS GuardDuty enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-gcp-armor",
            name="GCP Cloud Armor Scanner Detection",
            description="Detect vulnerability scanners via Cloud Armor security policies.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''resource.type="http_load_balancer"
httpRequest.userAgent=~"(?i)(Acunetix|Nikto|Nessus|OpenVAS|sqlmap|w3af|Nmap|Burp)"''',
                gcp_terraform_template="""# GCP: Detect vulnerability scanners via Cloud Armor

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email" {
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "vuln_scanners" {
  name   = "vulnerability-scanner-detection"
  filter = <<-EOT
    resource.type="http_load_balancer"
    httpRequest.userAgent=~"(?i)(Acunetix|Nikto|Nessus|OpenVAS|sqlmap|w3af|Nmap|Burp)"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
  }
}

resource "google_monitoring_alert_policy" "scanner_detected" {
  display_name = "Vulnerability Scanner Detected"
  combiner     = "OR"
  conditions {
    display_name = "High scanner activity"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.vuln_scanners.name}\""
      duration        = "300s"
      comparison      = "COMPARISON_GT"
      threshold_value = 20
    }
  }
  notification_channels = [google_monitoring_notification_channel.email.id]
}""",
                alert_severity="medium",
                alert_title="GCP: Vulnerability Scanner Detected",
                alert_description_template="Vulnerability scanning tools detected against load balancer.",
                investigation_steps=[
                    "Review scanner user-agent and source IP",
                    "Identify targeted endpoints",
                    "Check for successful exploitation",
                    "Correlate with security policy blocks",
                ],
                containment_actions=[
                    "Add Cloud Armor blocking rules",
                    "Review exposed services",
                    "Implement rate limiting",
                    "Harden application security",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Scanner signatures are distinctive; allowlist authorised scanners",
            detection_coverage="65% - detects tool-based scans",
            evasion_considerations="Custom scanners may evade signature detection",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-30",
            prerequisites=["Cloud Armor and load balancer logging enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-gcp-vpc",
            name="GCP VPC Flow Logs Port Scan Detection",
            description="Detect systematic port scanning via VPC Flow Logs.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''resource.type="gce_subnetwork"
log_name="projects/PROJECT_ID/logs/compute.googleapis.com%2Fvpc_flows"
jsonPayload.connection.src_ip!=""
jsonPayload.reporter="DEST"''',
                gcp_terraform_template="""# GCP: Detect port scanning via VPC Flow Logs

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email" {
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "port_scans" {
  name   = "port-scan-detection"
  filter = <<-EOT
    resource.type="gce_subnetwork"
    log_name="projects/${var.project_id}/logs/compute.googleapis.com%2Fvpc_flows"
    jsonPayload.reporter="DEST"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
    labels {
      key         = "src_ip"
      value_type  = "STRING"
      description = "Source IP address"
    }
  }
  label_extractors = {
    "src_ip" = "EXTRACT(jsonPayload.connection.src_ip)"
  }
}

resource "google_monitoring_alert_policy" "port_scan_detected" {
  display_name = "Port Scan Detected"
  combiner     = "OR"
  conditions {
    display_name = "High connection attempts"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.port_scans.name}\""
      duration        = "300s"
      comparison      = "COMPARISON_GT"
      threshold_value = 100
      aggregations {
        alignment_period   = "300s"
        per_series_aligner = "ALIGN_RATE"
      }
    }
  }
  notification_channels = [google_monitoring_notification_channel.email.id]
}""",
                alert_severity="medium",
                alert_title="GCP: Port Scanning Detected",
                alert_description_template="Systematic port scanning detected in VPC flow logs.",
                investigation_steps=[
                    "Identify scanning source and targets",
                    "Review scanned port ranges",
                    "Check for successful connections",
                    "Correlate with vulnerability scan signatures",
                ],
                containment_actions=[
                    "Add firewall rules to block source",
                    "Review and minimise exposed services",
                    "Enable Security Command Centre",
                    "Implement network segmentation",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Adjust thresholds for environment; allowlist legitimate scanners",
            detection_coverage="60% - detects systematic scanning patterns",
            evasion_considerations="Slow or distributed scans may evade",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-20",
            prerequisites=["VPC Flow Logs enabled"],
        ),
    ],
    recommended_order=[
        "t1595-002-aws-guardduty",
        "t1595-002-aws-waf",
        "t1595-002-gcp-armor",
        "t1595-002-aws-vpc",
        "t1595-002-gcp-vpc",
    ],
    total_effort_hours=6.5,
    coverage_improvement="+25% improvement for Reconnaissance tactic",
)
