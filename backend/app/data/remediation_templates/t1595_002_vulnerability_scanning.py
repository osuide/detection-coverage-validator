"""
T1595.002 - Active Scanning: Vulnerability Scanning

Adversaries conduct vulnerability scans to identify exploitable weaknesses in
target systems by examining software versions, configurations, and services.
Used by APT28, APT41, Ember Bear, Magic Hound, Sandworm Team.
"""

from .template_loader import (
    RemediationTemplate,
    ThreatContext,
    DetectionStrategy,
    DetectionImplementation,
    DetectionType,
    EffortLevel,
    FalsePositiveRate,
    CloudProvider,
)

TEMPLATE = RemediationTemplate(
    technique_id="T1595.002",
    technique_name="Active Scanning: Vulnerability Scanning",
    tactic_ids=["TA0043"],
    mitre_url="https://attack.mitre.org/techniques/T1595/002/",
    threat_context=ThreatContext(
        description=(
            "Adversaries conduct vulnerability scans on target systems to identify "
            "exploitable weaknesses. These scans examine software versions, configurations, "
            "running services, server banners, and network artifacts to discover commonly "
            "known vulnerabilities that could enable initial access or further reconnaissance."
        ),
        attacker_goal="Identify exploitable vulnerabilities in target infrastructure for initial access",
        why_technique=[
            "Identifies exploitable CVEs remotely",
            "Automated scanning tools widely available",
            "Reveals software versions and patch status",
            "Maps attack surface systematically",
            "Pre-compromise reconnaissance technique",
        ],
        known_threat_actors=[],
        recent_campaigns=[],  # Populated dynamically from MITRE sync data
        prevalence="common",
        trend="increasing",
        severity_score=7,
        severity_reasoning=(
            "Pre-compromise reconnaissance technique that identifies attack vectors. "
            "Occurs outside enterprise defences but directly enables exploitation attempts."
        ),
        business_impact=[
            "Identifies exploitable vulnerabilities",
            "Precedes targeted attacks",
            "Reveals security posture weaknesses",
            "Increases likelihood of breach",
        ],
        typical_attack_phase="reconnaissance",
        often_precedes=["T1190", "T1210", "T1068"],
        often_follows=["T1595.001", "T1590"],
    ),
    detection_strategies=[
        DetectionStrategy(
            strategy_id="t1595-002-aws-waf",
            name="AWS WAF Vulnerability Scan Detection",
            description="Detect vulnerability scanning activity via AWS WAF logs.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, httpRequest.clientIp, httpRequest.uri, httpRequest.headers
| filter httpRequest.headers like /(?i)(Acunetix|Nikto|Nessus|OpenVAS|sqlmap|w3af|Nmap|Burp)/
| stats count(*) as scans by httpRequest.clientIp, bin(5m)
| filter scans > 20
| sort scans desc""",
                cloudformation_template="""AWSTemplateFormatVersion: '2010-09-09'
Description: Detect vulnerability scanning via WAF logs

Parameters:
  WAFLogGroup:
    Type: String
  AlertEmail:
    Type: String

Resources:
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Protocol: email
          Endpoint: !Ref AlertEmail

  VulnScanFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref WAFLogGroup
      FilterPattern: '[... userAgent="*Acunetix*" || userAgent="*Nikto*" || userAgent="*Nessus*" || userAgent="*sqlmap*"]'
      MetricTransformations:
        - MetricName: VulnerabilityScans
          MetricNamespace: Security
          MetricValue: "1"

  VulnScanAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: VulnerabilityScanDetected
      MetricName: VulnerabilityScans
      Namespace: Security
      Statistic: Sum
      Period: 300
      Threshold: 20
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      TreatMissingData: notBreaching

      AlarmActions: [!Ref AlertTopic]""",
                terraform_template="""# Detect vulnerability scanning via WAF logs

variable "waf_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "vulnerability-scan-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "vuln_scans" {
  name           = "vulnerability-scans"
  log_group_name = var.waf_log_group
  pattern        = "[... userAgent=\"*Acunetix*\" || userAgent=\"*Nikto*\" || userAgent=\"*Nessus*\" || userAgent=\"*sqlmap*\"]"

  metric_transformation {
    name      = "VulnerabilityScans"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "vuln_scan_detected" {
  alarm_name          = "VulnerabilityScanDetected"
  metric_name         = "VulnerabilityScans"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 20
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}""",
                alert_severity="medium",
                alert_title="Vulnerability Scanning Detected",
                alert_description_template="Vulnerability scanning tools detected from {clientIp}.",
                investigation_steps=[
                    "Identify source IP and geolocation",
                    "Review scanning patterns and targets",
                    "Check for successful exploits following scans",
                    "Correlate with other reconnaissance activity",
                ],
                containment_actions=[
                    "Block scanning IP at WAF/security group",
                    "Review exposed services and patch status",
                    "Enable rate limiting on public endpoints",
                    "Verify no successful exploitation occurred",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Scanner user-agents are distinctive; authorised scans should be allowlisted",
            detection_coverage="65% - catches tool-based scans with identifiable signatures",
            evasion_considerations="Custom scanners with spoofed user-agents may evade",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-25",
            prerequisites=["AWS WAF with logging enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-aws-vpc",
            name="VPC Flow Logs Port Scan Detection",
            description="Detect systematic port scanning via VPC Flow Logs.",
            detection_type=DetectionType.CLOUDWATCH_QUERY,
            aws_service="cloudwatch",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""fields @timestamp, srcaddr, dstaddr, dstport, protocol, action
| filter action = "REJECT"
| stats count_distinct(dstport) as ports by srcaddr, bin(5m)
| filter ports > 50
| sort ports desc""",
                terraform_template="""# Detect port scanning via VPC Flow Logs

variable "vpc_flow_log_group" { type = string }
variable "alert_email" { type = string }

resource "aws_sns_topic" "alerts" {
  name = "port-scan-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

resource "aws_cloudwatch_log_metric_filter" "port_scans" {
  name           = "port-scans"
  log_group_name = var.vpc_flow_log_group
  pattern        = "[version, account, eni, source, destination, srcport, destport, protocol, packets, bytes, windowstart, windowend, action=REJECT, flowlogstatus]"

  metric_transformation {
    name      = "PortScans"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "port_scan_detected" {
  alarm_name          = "PortScanDetected"
  metric_name         = "PortScans"
  namespace           = "Security"
  statistic           = "Sum"
  period              = 300
  threshold           = 100
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  treat_missing_data  = "notBreaching"

  alarm_actions       = [aws_sns_topic.alerts.arn]
}""",
                alert_severity="medium",
                alert_title="Port Scanning Activity Detected",
                alert_description_template="Multiple port connection attempts from {srcaddr}.",
                investigation_steps=[
                    "Identify scanning source and target systems",
                    "Review port ranges being scanned",
                    "Check for subsequent exploitation attempts",
                    "Correlate with vulnerability scan signatures",
                ],
                containment_actions=[
                    "Block source IP at network ACL",
                    "Review security group configurations",
                    "Minimise exposed services",
                    "Enable GuardDuty if not present",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Adjust threshold based on legitimate scanning; allowlist authorised security scanners",
            detection_coverage="60% - detects systematic port enumeration",
            evasion_considerations="Slow scans and targeted scanning may evade thresholds",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-15",
            prerequisites=["VPC Flow Logs enabled and published to CloudWatch"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-aws-guardduty",
            name="AWS GuardDuty Port Scan Detection",
            description="Leverage GuardDuty's built-in port scanning detection.",
            detection_type=DetectionType.CONFIG_RULE,
            aws_service="guardduty",
            cloud_provider=CloudProvider.AWS,
            implementation=DetectionImplementation(
                query="""# GuardDuty Finding Types for Port Scanning:
# - Recon:EC2/PortProbeUnprotectedPort
# - Recon:EC2/PortProbeEMRUnprotectedPort
# - Recon:EC2/Portscan""",
                terraform_template="""# Configure GuardDuty alerts for port scanning

variable "alert_email" { type = string }

resource "aws_guardduty_detector" "main" {
  enable = true
  finding_publishing_frequency = "FIFTEEN_MINUTES"
}

resource "aws_sns_topic" "guardduty_alerts" {
  name = "guardduty-port-scan-alerts"
  kms_master_key_id = "alias/aws/sns"
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.guardduty_alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Dead Letter Queue for EventBridge targets
resource "aws_sqs_queue" "events_dlq" {
  name                      = "guardduty-port-scan-dlq"
  message_retention_seconds = 1209600
}

resource "aws_sqs_queue_policy" "events_dlq" {
  queue_url = aws_sqs_queue.events_dlq.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Principal = {
        Service = "events.amazonaws.com"
      }
      Action   = "sqs:SendMessage"
      Resource = aws_sqs_queue.events_dlq.arn
    }]
  })
}

resource "aws_cloudwatch_event_rule" "port_scan" {
  name        = "guardduty-port-scan"
  description = "Capture GuardDuty port scanning findings"

  event_pattern = jsonencode({
    source      = ["aws.guardduty"]
    detail-type = ["GuardDuty Finding"]
    detail = {
      type = [
        "Recon:EC2/PortProbeUnprotectedPort",
        "Recon:EC2/PortProbeEMRUnprotectedPort",
        "Recon:EC2/Portscan"
      ]
    }
  })
}

resource "aws_cloudwatch_event_target" "sns" {
  rule      = aws_cloudwatch_event_rule.port_scan.name
  target_id = "SendToSNS"
  arn       = aws_sns_topic.guardduty_alerts.arn

  retry_policy {
    maximum_event_age_in_seconds = 3600
    maximum_retry_attempts       = 8
  }

  dead_letter_config {
    arn = aws_sqs_queue.events_dlq.arn
  }
  input_transformer {
    input_paths = {
      account    = "$.account"
      region     = "$.region"
      time       = "$.time"
      type       = "$.detail.type"
      severity   = "$.detail.severity"
      title      = "$.detail.title"
      description = "$.detail.description"
    }

    input_template = <<-EOT
"GuardDuty Finding Alert
Time: <time>
Account: <account>
Region: <region>
Finding: <type>
Severity: <severity>
Title: <title>
Description: <description>
Action: Review finding in GuardDuty console and investigate"
EOT
  }

}

# Allow EventBridge to publish to SNS
data "aws_caller_identity" "current" {}

resource "aws_sns_topic_policy" "allow_eventbridge" {
  arn = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect    = "Allow"
      Principal = { Service = "events.amazonaws.com" }
      Action    = "sns:Publish"
      Resource  = aws_sns_topic.alerts.arn
    Condition = {
        StringEquals = {
          "AWS:SourceAccount" = data.aws_caller_identity.current.account_id
        }
        ArnEquals = {
          "aws:SourceArn" = aws_cloudwatch_event_rule.port_scan.arn
        }
      }
    }]
  })
}""",
                alert_severity="medium",
                alert_title="GuardDuty: Port Scanning Detected",
                alert_description_template="GuardDuty detected port scanning activity against your infrastructure.",
                investigation_steps=[
                    "Review GuardDuty finding details and severity",
                    "Identify targeted instances and services",
                    "Check for successful connections post-scan",
                    "Review network configuration",
                ],
                containment_actions=[
                    "Block malicious IPs via security groups",
                    "Review and harden exposed services",
                    "Implement network segmentation",
                    "Enable additional monitoring",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="GuardDuty findings are pre-tuned; suppress known scanners",
            detection_coverage="80% - comprehensive managed detection",
            evasion_considerations="Very slow or distributed scans may evade",
            implementation_effort=EffortLevel.LOW,
            implementation_time="30 minutes",
            estimated_monthly_cost="$30-100 (GuardDuty service)",
            prerequisites=["AWS GuardDuty enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-gcp-armor",
            name="GCP Cloud Armor Scanner Detection",
            description="Detect vulnerability scanners via Cloud Armor security policies.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''resource.type="http_load_balancer"
httpRequest.userAgent=~"(?i)(Acunetix|Nikto|Nessus|OpenVAS|sqlmap|w3af|Nmap|Burp)"''',
                gcp_terraform_template="""# GCP: Detect vulnerability scanners via Cloud Armor

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email_s1" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "vuln_scanners" {
  project = var.project_id
  name   = "vulnerability-scanner-detection"
  filter = <<-EOT
    resource.type="http_load_balancer"
    httpRequest.userAgent=~"(?i)(Acunetix|Nikto|Nessus|OpenVAS|sqlmap|w3af|Nmap|Burp)"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
  }
}

resource "google_monitoring_alert_policy" "scanner_detected" {
  project      = var.project_id
  display_name = "Vulnerability Scanner Detected"
  combiner     = "OR"
  conditions {
    display_name = "High scanner activity"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.vuln_scanners.name}\""
      duration        = "300s"
      comparison      = "COMPARISON_GT"
      threshold_value = 20
    }
  }
  notification_channels = [google_monitoring_notification_channel.email_s1.id]

  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="medium",
                alert_title="GCP: Vulnerability Scanner Detected",
                alert_description_template="Vulnerability scanning tools detected against load balancer.",
                investigation_steps=[
                    "Review scanner user-agent and source IP",
                    "Identify targeted endpoints",
                    "Check for successful exploitation",
                    "Correlate with security policy blocks",
                ],
                containment_actions=[
                    "Add Cloud Armor blocking rules",
                    "Review exposed services",
                    "Implement rate limiting",
                    "Harden application security",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.LOW,
            false_positive_tuning="Scanner signatures are distinctive; allowlist authorised scanners",
            detection_coverage="65% - detects tool-based scans",
            evasion_considerations="Custom scanners may evade signature detection",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-30",
            prerequisites=["Cloud Armor and load balancer logging enabled"],
        ),
        DetectionStrategy(
            strategy_id="t1595-002-gcp-vpc",
            name="GCP VPC Flow Logs Port Scan Detection",
            description="Detect systematic port scanning via VPC Flow Logs.",
            detection_type=DetectionType.CLOUD_LOGGING_QUERY,
            aws_service="n/a",
            gcp_service="cloud_logging",
            cloud_provider=CloudProvider.GCP,
            implementation=DetectionImplementation(
                gcp_logging_query='''resource.type="gce_subnetwork"
log_name="projects/PROJECT_ID/logs/compute.googleapis.com%2Fvpc_flows"
jsonPayload.connection.src_ip!=""
jsonPayload.reporter="DEST"''',
                gcp_terraform_template="""# GCP: Detect port scanning via VPC Flow Logs

variable "project_id" { type = string }
variable "alert_email" { type = string }

resource "google_monitoring_notification_channel" "email_s2" {
  project      = var.project_id
  display_name = "Security Alerts"
  type         = "email"
  labels       = { email_address = var.alert_email }
}

resource "google_logging_metric" "port_scans" {
  name   = "port-scan-detection"
  filter = <<-EOT
    resource.type="gce_subnetwork"
    log_name="projects/${var.project_id}/logs/compute.googleapis.com%2Fvpc_flows"
    jsonPayload.reporter="DEST"
  EOT
  metric_descriptor {
    metric_kind = "DELTA"
    value_type  = "INT64"
    labels {
      key         = "src_ip"
      value_type  = "STRING"
      description = "Source IP address"
    }
  }
  label_extractors = {
    "src_ip" = "EXTRACT(jsonPayload.connection.src_ip)"
  }
}

resource "google_monitoring_alert_policy" "port_scan_detected" {
  project      = var.project_id
  display_name = "Port Scan Detected"
  combiner     = "OR"
  conditions {
    display_name = "High connection attempts"
    condition_threshold {
      filter          = "metric.type=\"logging.googleapis.com/user/${google_logging_metric.port_scans.name}\""
      duration        = "300s"
      comparison      = "COMPARISON_GT"
      threshold_value = 100
      aggregations {
        alignment_period   = "300s"
        per_series_aligner = "ALIGN_RATE"
      }
    }
  }
  notification_channels = [google_monitoring_notification_channel.email_s2.id]

  alert_strategy {
    auto_close = "1800s"
    notification_rate_limit {
      period = "300s"
    }
  }
}""",
                alert_severity="medium",
                alert_title="GCP: Port Scanning Detected",
                alert_description_template="Systematic port scanning detected in VPC flow logs.",
                investigation_steps=[
                    "Identify scanning source and targets",
                    "Review scanned port ranges",
                    "Check for successful connections",
                    "Correlate with vulnerability scan signatures",
                ],
                containment_actions=[
                    "Add firewall rules to block source",
                    "Review and minimise exposed services",
                    "Enable Security Command Centre",
                    "Implement network segmentation",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning="Adjust thresholds for environment; allowlist legitimate scanners",
            detection_coverage="60% - detects systematic scanning patterns",
            evasion_considerations="Slow or distributed scans may evade",
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$5-20",
            prerequisites=["VPC Flow Logs enabled"],
        ),
        # Azure Strategy: Active Scanning: Vulnerability Scanning
        DetectionStrategy(
            strategy_id="t1595002-azure",
            name="Azure Active Scanning: Vulnerability Scanning Detection",
            description=(
                "Azure detection for Active Scanning: Vulnerability Scanning. "
                "Provides native Azure detection using Log Analytics and Defender for Cloud."
            ),
            detection_type=DetectionType.LOG_ANALYTICS_QUERY,
            aws_service="n/a",
            azure_service="log_analytics",
            cloud_provider=CloudProvider.AZURE,
            implementation=DetectionImplementation(
                azure_kql_query="""// Active Scanning: Vulnerability Scanning Detection
// Technique: T1595.002
AzureActivity
| where TimeGenerated > ago(24h)
| where CategoryValue == "Administrative"
| where ActivityStatusValue == "Success" or ActivityStatusValue == "Succeeded"
| summarize
    OperationCount = count(),
    UniqueCallers = dcount(Caller),
    Resources = make_set(Resource, 10)
    by Caller, CallerIpAddress, bin(TimeGenerated, 1h)
| where OperationCount > 10
| order by OperationCount desc""",
                azure_terraform_template="""# Azure Detection for Active Scanning: Vulnerability Scanning
# MITRE ATT&CK: T1595.002

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = ">= 3.0"
    }
  }
}

variable "resource_group_name" {
  type        = string
  description = "Resource group for Log Analytics workspace"
}

variable "log_analytics_workspace_id" {
  type        = string
  description = "Log Analytics workspace resource ID"
}

variable "alert_email" {
  type        = string
  description = "Email for security alerts"
}

variable "location" {
  type        = string
  description = "Azure region for resources"
  default     = "uksouth"
}

# Action Group for alerts
resource "azurerm_monitor_action_group" "security_alerts" {
  name                = "active-scanning--vulnerability-scanning-alerts"
  resource_group_name = var.resource_group_name
  short_name          = "SecAlerts"

  email_receiver {
    name          = "security-team"
    email_address = var.alert_email
  }
}

# Scheduled Query Rule for detection
resource "azurerm_monitor_scheduled_query_rules_alert_v2" "detection" {
  name                = "active-scanning--vulnerability-scanning-detection"
  resource_group_name = var.resource_group_name
  location            = var.location

  evaluation_frequency = "PT5M"
  window_duration      = "PT1H"
  scopes               = [var.log_analytics_workspace_id]
  severity             = 2

  criteria {
    query = <<-QUERY
// Active Scanning: Vulnerability Scanning Detection
// Technique: T1595.002
AzureActivity
| where TimeGenerated > ago(24h)
| where CategoryValue == "Administrative"
| where ActivityStatusValue == "Success" or ActivityStatusValue == "Succeeded"
| summarize
    OperationCount = count(),
    UniqueCallers = dcount(Caller),
    Resources = make_set(Resource, 10)
    by Caller, CallerIpAddress, bin(TimeGenerated, 1h)
| where OperationCount > 10
| order by OperationCount desc
    QUERY

    time_aggregation_method = "Count"
    threshold               = 1
    operator                = "GreaterThanOrEqual"

    failing_periods {
      minimum_failing_periods_to_trigger_alert = 1
      number_of_evaluation_periods             = 1
    }
  }

  auto_mitigation_enabled = false

  action {
    action_groups = [azurerm_monitor_action_group.security_alerts.id]
  }

  description = "Detects Active Scanning: Vulnerability Scanning (T1595.002) activity in Azure environment"
  display_name = "Active Scanning: Vulnerability Scanning Detection"
  enabled      = true

  tags = {
    "mitre-technique" = "T1595.002"
    "detection-type"  = "security"
  }
}

output "alert_rule_id" {
  value = azurerm_monitor_scheduled_query_rules_alert_v2.detection.id
}""",
                alert_severity="high",
                alert_title="Azure: Active Scanning: Vulnerability Scanning Detected",
                alert_description_template=(
                    "Active Scanning: Vulnerability Scanning activity detected. "
                    "Caller: {Caller}. Resource: {Resource}."
                ),
                investigation_steps=[
                    "Review Azure Activity Log for full operation details",
                    "Check caller identity and verify if authorised",
                    "Review affected resources and assess impact",
                    "Check for related activities in the same time window",
                    "Verify against change management records",
                ],
                containment_actions=[
                    "Disable compromised user/service principal if unauthorised",
                    "Revoke active sessions using Entra ID",
                    "Review and restrict Azure RBAC permissions",
                    "Enable additional Defender for Cloud protections",
                    "Implement Azure Policy to prevent recurrence",
                ],
            ),
            estimated_false_positive_rate=FalsePositiveRate.MEDIUM,
            false_positive_tuning=(
                "Allowlist known automation accounts and CI/CD service principals. "
                "Use Azure Policy to define expected behaviour baselines."
            ),
            detection_coverage="70% - Azure-native detection for cloud operations",
            evasion_considerations=(
                "Attackers may use legitimate credentials from expected locations. "
                "Combine with Defender for Cloud for ML-based anomaly detection."
            ),
            implementation_effort=EffortLevel.MEDIUM,
            implementation_time="1-2 hours",
            estimated_monthly_cost="$10-50 (Log Analytics + Defender)",
            prerequisites=[
                "Azure subscription with Log Analytics workspace",
                "Defender for Cloud enabled (recommended)",
                "Appropriate Azure RBAC permissions for deployment",
            ],
        ),
    ],
    recommended_order=[
        "t1595-002-aws-guardduty",
        "t1595-002-aws-waf",
        "t1595-002-gcp-armor",
        "t1595-002-aws-vpc",
        "t1595-002-gcp-vpc",
    ],
    total_effort_hours=6.5,
    coverage_improvement="+25% improvement for Reconnaissance tactic",
)
